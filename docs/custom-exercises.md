# Экран пользовательских упражнений (Custom Exercises)

Этот документ описывает реализованный функционал экрана пользовательских упражнений, устройство локального хранения, офлайн-приоритет и логику сервиса `CustomExercisesService.swift`.

## Оглавление

- [Краткий обзор функционала](#краткий-обзор-функционала)
- [Модель данных: `CustomExercise`](#модель-данных-customexercise)
- [Офлайн-приоритет](#офлайн-приоритет)
- [Сетевая интеграция (через `ExerciseClient`/`SWClient`)](#сетевая-интеграция-через-exerciseclientswclient)
- [Сервис: `CustomExercisesService`](#сервис-customexercisesservice)
- [Вспомогательные структуры](#вспомогательные-структуры)
- [Логирование](#логирование)
- [UI: взаимодействие и поведение](#ui-взаимодействие-и-поведение)
- [Тестирование и качество](#тестирование-и-качество)
- [Принципы расширения](#принципы-расширения)
- [Ключевые правила](#ключевые-правила)

### Краткий обзор функционала

- **Список упражнений**: отображение пользовательских упражнений текущего пользователя, скрытие элементов, помеченных к удалению.
- **Пустое состояние**: CTA для создания первого упражнения.
- **Поиск и фильтр**: фильтрация по названию (локально, без сети).
- **Создание**: форма ввода названия и выбора иконки, локальное сохранение, последующая синхронизация в фоне.
- **Редактирование**: предзаполнение полей, локальное сохранение изменений, последующая синхронизация.
- **Удаление**: мягкое удаление (soft delete) — элемент помечается флагом, сразу скрывается из UI, серверное удаление асинхронно.
- **Навигация**: переходы список → добавление → редактирование.
- **Доступность и логирование**: логи на русском, UI не блокируется синхронизацией.

### Модель данных: `CustomExercise`

- `id: String` — идентификатор (локально создается как timestamp + случайное число, затем согласуется с сервером по тому же значению).
- `name: String` — название упражнения; локальная защита от дубликатов по имени для текущего пользователя.
- `imageId: Int` — идентификатор иконки.
- `createDate: Date` — дата создания.
- `modifyDate: Date` — дата последнего изменения (используется как источник истины при разрешении конфликтов; аналог lastModified).
- `isSynced: Bool` — синхронизировано ли состояние с сервером.
- `shouldDelete: Bool` — пометка на удаление (элемент скрывается из UI, удаляется на сервере при следующей синхронизации, затем удаляется локально физически).
- `user: User?` — связь с пользователем (Relationship в SwiftData).

**Дополнительные методы модели:**
- `fetch(by:id, in:context)` — статический метод для получения упражнения по ID из контекста.
- `image: Image` — computed property для получения иконки упражнения.
- `hasDataChanged(comparedTo:)` — проверка изменений данных по сравнению с ответом сервера.
- `exerciseSnapshot: ExerciseSnapshot` — преобразование в снимок для конкурентной синхронизации.

### Офлайн-приоритет

- Все операции (создание, обновление, удаление) сначала сохраняются локально в SwiftData.
- Синхронизация с сервером выполняется асинхронно, неблокирующе для обычных пользовательских действий.
- При сетевых ошибках работа продолжается локально; состояние помечается как несинхронизированное.
- Конфликты разрешаются автоматически по стратегии LWW (Last Write Wins) на основе поля `modifyDate`.

### Сетевая интеграция (через `ExerciseClient`/`SWClient`)

- `GET v3/100/custom_exercises` — получение списка пользовательских упражнений.
- `POST v3/100/custom_exercises/<id>` — создание/обновление упражнения.
- `DELETE v3/100/custom_exercises/<id>` — удаление упражнения.

Интерфейс клиента (сокращенно):
- `getCustomExercises() async throws -> [CustomExerciseResponse]`
- `saveCustomExercise(id: String, exercise: CustomExerciseRequest) async throws -> CustomExerciseResponse`
- `deleteCustomExercise(id: String) async throws`

Модели запросов/ответов содержат ISO-строки дат (`create_date`, `modify_date`) и поля `name`, `image_id`, `is_hidden`.

### Сервис: `CustomExercisesService`

Сервис помечен `@MainActor` и `@Observable`. Все логи — на русском языке (`OSLog`).

- **Публичные свойства**:
  - `isLoading: Bool` — индикатор общей синхронизации (двунаправленной).
  - `isSyncing: Bool` — индикатор отправки несинхронизированных изменений.

- **Создание**: `createCustomExercise(name:imageId:context:)`
  - Защищает от локального конфликта имен для текущего пользователя (добавляет суффикс со временем, если имя занято и элемент не помечен к удалению).
  - Создает локальный `id` на основе `timestamp` + случайного числа.
  - Вставляет в SwiftData и сохраняет; ставит `isSynced = false` (по умолчанию) и актуальную `modifyDate`.
  - Логи: успешное локальное создание и указание, что синхронизация выполняется отдельно.

- **Пометка как измененного**: `markCustomExerciseAsModified(_:context:)`
  - Проставляет `modifyDate = now` и `isSynced = false`, затем сохраняет контекст.
  - Может выбрасывать ошибку при сохранении контекста.
  - Синхронизация изменений выполняется отдельно через `syncCustomExercises(context:)`.

- **Удаление (soft)**: `deleteCustomExercise(_:context:)`
  - Не удаляет объект физически сразу.
  - Ставит `shouldDelete = true`, `isSynced = false`, обновляет `modifyDate` и сохраняет контекст.
  - UI фильтрует такие элементы и не показывает их пользователю.

- **Синхронизация несинхронизированных**: `syncUnsyncedExercises(context:)`
  - Реализована схема snapshot → group → apply.
  - На этапе snapshot: из `ModelContext` собираются только необходимые неизменяемые данные (`ExerciseSnapshot`) через `makeExerciseSnapshotsForSync`.
  - На этапе group: параллельно (через `withTaskGroup`) выполняются чистые сетевые операции без доступа к `ModelContext` через `runSyncTasks`, для каждого снимка формируется `SyncEvent`:
    - `.createdOrUpdated(id:server)` — сервер вернул актуальную сущность.
    - `.deleted(id)` — сервер подтвердил удаление.
    - `.failed(id:errorDescription)` — ошибка сети/сервера.
  - На этапе apply: все события применяются к `ModelContext` одним проходом на главной очереди через `applySyncEvents`:
    - Для `createdOrUpdated` — обновление локальной сущности данными ответа сервера с проверкой дат (LWW), `isSynced = true`, `shouldDelete = false`, даты приводятся из серверных строк.
    - Для `deleted` — физическое удаление локального объекта.
    - Для `failed` — только логирование, локальное состояние сохраняется для последующих повторов.
  - Возвращает кортеж `(SyncStats, [SyncError])` со статистикой и ошибками.

- **Двунаправленная синхронизация**: `syncCustomExercises(context:) async throws -> SyncResult`
  - Возвращает `SyncResult` с детальной информацией о результатах синхронизации (статистика, ошибки).
  - Защита от повторного запуска: выбрасывает `AlreadySyncingError`, если синхронизация уже выполняется.
  - Сначала вызывает `syncUnsyncedExercises` (локальные → сервер) и собирает статистику и ошибки.
  - Затем `downloadServerExercises` (сервер → локальные) с автоматическим разрешением конфликтов по LWW.
  - Ошибки загрузки с сервера также добавляются в список ошибок результата.
  - Формирует `SyncResult` с типом результата (success/partial/error) на основе наличия ошибок и статистики.

- **Загрузка с сервера и LWW**: `downloadServerExercises(context:)`
  - Загружает все упражнения пользователя и сопоставляет с локальными по `id`.
  - Порядок проверок для разрешения конфликтов:
    1. Если локальная сущность помечена `shouldDelete` — пропускается обновление (не восстанавливается серверными данными).
    2. Если данные не изменились (`hasDataChanged == false`) и упражнение синхронизировано — пропускается обновление.
    3. Если локальное упражнение имеет несинхронизированные изменения (`isSynced = false`) — пропускается обновление с сервера (локальные изменения имеют приоритет).
    4. Сравнение дат для синхронизированных упражнений с измененными данными:
       - Если `local.modifyDate > server.modify_date` — сохраняется локальная версия (локальная версия новее).
       - Если `server.modify_date > local.modifyDate` — локальная сущность обновляется по данным сервера и помечается синхронизированной.
  - Для синхронизированных элементов, отсутствующих на сервере, — ставится `shouldDelete = true` и `isSynced = false` (или выполняется физическое удаление, если удаление уже подтверждалось событием).
  - Логи: детальное отслеживание разрешения конфликтов с временными метками для сравнения дат.

- **Повторные попытки**: в сервисе предусмотрен частный механизм повторов для поштучной синхронизации (метод `syncSingleExerciseWithRetry` с максимум 3 попытками и задержкой 2 секунды), но основным путем является групповая синхронизация `syncUnsyncedExercises`.

### Вспомогательные структуры

- **`ExerciseSnapshot`**: неизменяемый снимок данных упражнения для безопасной конкурентной синхронизации без доступа к `ModelContext`. Содержит все необходимые поля (`id`, `name`, `imageId`, `createDate`, `modifyDate`, `isSynced`, `shouldDelete`, `userId`) и метод `exerciseRequest` для преобразования в `CustomExerciseRequest`.

### Логирование

- **Все сообщения на русском языке**:
  - Старт/завершение синхронизаций, количество элементов к синку.
  - Подробности запросов при отправке (id, name, image_id, даты).
  - Результаты применения: «обновлено локально», «удалено локально», «пропущено (локальная версия новее)».
  - Ошибки сети/применения с `error.localizedDescription` и деталями `APIError`, если доступен.
  - Детальное логирование разрешения конфликтов с временными метками для сравнения дат.

### UI: взаимодействие и поведение

- Обычные операции создания/редактирования/удаления не блокируют UI; синхронизация происходит в фоне.
- Элементы с `shouldDelete == true` скрываются из списка через `@Query` с предикатом.
- Поиск реализован локально через фильтрацию по названию (без сети).
- Удаление через swipe actions с подтверждением через `confirmationDialog`.
- Навигация: список → детальный просмотр → редактирование (через `NavigationLink` и `sheet`).

### Тестирование и качество

- Юнит-тесты модели формы (проверка дубликатов, валидация, генерация новой модели) — планируются/поддерживаются средствами Swift Testing.
- Юнит-тесты сервиса с моками клиента: 
  - успех/ошибка сохранения, удаления, конфликтов; 
  - корректность применения событий `SyncEvent` и стратегии LWW.
- Проверки локализации пользовательских строк и корректности логов (на русском).

### Принципы расширения

- Новые поля в `CustomExercise` добавлять с учетом мягких миграций SwiftData.
- Для новых операций соблюдать офлайн-приоритет: локальные изменения в первую очередь, синхронизация — отдельно и неблокирующе.
- Все сетевые операции — через абстракции клиентов (`ExerciseClient`), без прямых вызовов внутри View.

### Ключевые правила

- Не блокировать UI ожиданием сети в экране упражнений.
- Всегда писать логи на русском с достаточным контекстом.
- Разрешать конфликты автоматически по `modifyDate`.
- Soft delete: сначала пометка и скрытие в UI, потом удаление на сервере и физическое удаление локально.
