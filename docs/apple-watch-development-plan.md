# План разработки приложения для Apple Watch

## Обзор

Этот документ описывает детальный план разработки приложения для Apple Watch с сокращенным функционалом по сравнению с основным iOS-приложением. Приложение для часов будет поддерживать выбор типа активности на день и выполнение тренировок с синхронизацией данных между часами и iPhone.

## Цели и ограничения

### Функционал для часов
- Выбор типа активности на сегодняшний день из 4 вариантов (`DayActivityType`):
  - `workout` - тренировка
  - `stretch` - растяжка
  - `rest` - отдых
  - `sick` - болезнь
- Выполнение тренировки (если выбран тип `workout`):
  - Упрощенный интерфейс выполнения тренировки
  - Сохранение результата тренировки
- Синхронизация данных между часами и iPhone:
  - Двусторонняя синхронизация через WatchConnectivity
  - Синхронизация выбранных активностей
  - Синхронизация результатов тренировок
  - Синхронизация текущего дня программы

### Ограничения
- Минимальный UI для часов (ограниченный размер экрана)
- Упрощенная логика тренировок (без сложных настроек)
- **Часы не хранят данные локально** - все данные запрашиваются с iPhone и сохраняются через iPhone в SwiftData
- **Статус авторизации и номер текущего дня** передаются через WatchConnectivity (см. раздел 1.3)
- **Текущий день** получается только из WatchConnectivity (готовый номер дня), при отсутствии связи показывается `AuthRequiredView`
- **iPhone приложение является единственным хранилищем данных** (SwiftData)
- **Приложение для часов работает только после успешной авторизации в iPhone приложении**

## Архитектура

### Структура проекта

```
SotkaWatch Watch App/
├── Models/
│   └── AuthState.swift                 # Модель состояния авторизации для Watch App ✅
├── Services/
│   ├── WatchAuthService.swift          # Сервис авторизации для Watch App ✅
│   ├── WatchAuthServiceProtocol.swift  # Протокол сервиса авторизации ✅
│   ├── WatchConnectivityService.swift  # Сервис связи с iPhone через WatchConnectivity ✅
│   ├── WatchConnectivityServiceProtocol.swift # Протокол сервиса связи ✅
│   ├── WatchWorkoutService.swift       # Сервис тренировок для Watch App ✅
│   └── WCSessionProtocol.swift         # Протокол для WCSession (для тестирования) ✅
├── ViewModels/
│   ├── HomeViewModel.swift              # ViewModel для главного экрана ✅
│   ├── WorkoutViewModel.swift          # ViewModel для экрана тренировки ✅
│   └── WorkoutPreviewViewModel.swift   # ViewModel для экрана превью тренировки ✅
├── Views/
│   ├── AuthRequiredView.swift          # Экран для неавторизованных пользователей ✅
│   ├── HomeView.swift                  # Главный экран часов ✅
│   ├── DayActivityView.swift           # Экран активности дня (выбор/отображение) ✅
│   ├── DayActivitySelectionView.swift  # Выбор типа активности ✅
│   ├── SelectedActivityView.swift      # Отображение выбранной активности ✅
│   ├── WatchDayActivityTrainingView.swift # Компонент отображения данных тренировки ✅
│   ├── WatchDayActivityCommentView.swift  # Компонент отображения комментария ✅
│   ├── WorkoutPreviewView.swift        # Экран превью тренировки ✅
│   ├── WorkoutEditView.swift           # Экран редактирования упражнений в тренировке ✅
│   ├── WorkoutStepperView.swift        # Компонент для изменения значений (stepper) ✅
│   ├── WorkoutView.swift               # Экран выполнения тренировки ✅
│   └── WorkoutRestTimerView.swift      # Таймер отдыха между кругами/подходами ✅

Примечание: 
- Модели данных переиспользуются из основного приложения, локальные модели для Watch App размещаются в `Models/`
- Модели для этапов тренировки (WorkoutStep, WorkoutState, WorkoutStepState) добавлены в Watch App target
- Простые структуры получают Codable для передачи через WatchConnectivity, модели с `@Model` (SwiftData) не используются на часах
- Ассеты упражнений в отдельном `ExercisesAssets.xcassets`, доступном обоим таргетам
```

### Технологии

- **SwiftUI** - для UI (watchOS поддерживает SwiftUI)
- **WatchConnectivity** - для связи с iPhone
- **OSLog** - для логирования

**Важно:** 
- Часы не используют SwiftData, все данные запрашиваются с iPhone в реальном времени
- Модели переиспользуются из основного приложения, простые структуры получают Codable для передачи через WatchConnectivity
- UIKit API недоступны на watchOS: методы, использующие `UIImpactFeedbackGenerator`, `UIViewControllerRepresentable` и другие UIKit компоненты, должны быть исключены из компиляции для watchOS через `#if !os(watchOS)` или помечены `@available(watchOS, unavailable)`
- Платформо-специфичные SwiftUI компоненты (например, `TextFieldLink` для watchOS) должны быть обернуты в условную компиляцию `#if os(watchOS)`

### Обмен данными между часами и iPhone

#### WatchConnectivity Service

**Архитектура связи:**
- iPhone - единственное хранилище данных (SwiftData)
- Часы не хранят данные локально - все данные получаются только через WatchConnectivity в реальном времени
- Все действия с часов передаются в iPhone через WatchConnectivity (`sendMessage`)
- Статус авторизации и номер текущего дня передаются через WatchConnectivity, при отсутствии связи показывается `AuthRequiredView`

**Команды синхронизации:** (см. раздел "Команды WatchConnectivity" ниже)

**Механизмы передачи данных:**
- `sendMessage` - для немедленной передачи данных, требует активного соединения

**Формат данных:**
- JSON для передачи сложных структур
- Простые типы (Int, String, Bool) для простых команд

#### Разрешение конфликтов при одновременном изменении активности

**Проблема:**
При одновременном изменении активности на один и тот же день с разных устройств (часы и iPhone) могут возникать конфликты. Например:
- На iPhone начали тренировку (создана активность `.workout`), но не закончили и свернули приложение
- На часах выбрали активность "отдых" для того же дня
- Без специальной обработки активность будет перезаписана на "отдых", что приведет к потере данных о тренировке

**Стратегия разрешения конфликтов:**

1. **Приоритет незавершенных тренировок:**
   - Если на день уже существует активность типа `.workout` (тренировка), изменение на другой тип активности (`.rest`, `.stretch`, `.sick`) должно быть запрещено или требовать подтверждения
   - Это предотвращает случайную потерю данных о начатой тренировке
   - Проверка выполняется на iPhone при обработке команды `WATCH_COMMAND_SET_ACTIVITY` от часов

2. **Last Write Wins (LWW) для других случаев:**
   - Для активностей типа `.rest`, `.stretch`, `.sick` применяется стратегия LWW на основе `modifyDate`
   - Последнее изменение побеждает (обновляется `modifyDate` при каждом изменении)
   - Это соответствует существующей логике разрешения конфликтов при синхронизации с сервером

3. **Проверка перед изменением:**
   - При получении команды `WATCH_COMMAND_SET_ACTIVITY` на iPhone:
     - Проверить существующую активность для указанного дня
     - Если активность существует и имеет тип `.workout`:
       - Отклонить изменение (вернуть ошибку на часы)
       - Или запросить подтверждение у пользователя (если изменение запрошено с iPhone)
     - Если активность не существует или имеет другой тип - выполнить изменение

4. **Уведомление пользователя:**
   - При попытке изменить активность на часах, если на iPhone есть незавершенная тренировка:
     - Показать сообщение об ошибке на часах: "Нельзя изменить активность: на телефоне начата тренировка"
     - Предложить завершить тренировку на телефоне или отменить её перед изменением активности

5. **Специальный случай - завершенные тренировки:**
   - Если тренировка завершена (есть `count` и `duration`), изменение на другой тип активности разрешено
   - Это позволяет пользователю изменить активность после завершения тренировки

**Реализация:**
- Логика проверки конфликтов реализуется в `WatchConnectivityManager` на iPhone при обработке команды `WATCH_COMMAND_SET_ACTIVITY`
- Используется `DailyActivitiesService` для проверки существующей активности
- При обнаружении конфликта возвращается ошибка на часы через WatchConnectivity
- Часы обрабатывают ошибку и показывают соответствующее сообщение пользователю

**Примечание:**
- Эта стратегия применяется только для конфликтов между часами и iPhone
- Конфликты при синхронизации с сервером разрешаются по существующей логике LWW в `DailyActivitiesService.downloadServerActivities()`

## Детальный план реализации

**Важно:** План следует принципам TDD (Test-Driven Development). Сначала пишутся тесты, затем реализация. UI реализуется в последнюю очередь.

### Принципы локализации для Watch App

1. **Использование общего файла локализации:**
   - Файл `SupportingFiles/Localizable.xcstrings` уже добавлен в Watch App target
   - Все строки для часов добавляются в этот же файл с префиксом `Watch.*`
   - Использование общего файла упрощает поддержку и позволяет переиспользовать общие строки

2. **Локализация displayName для часов:** ✅ Выполнено (см. раздел 1.2)

3. **Избежание дублей ключей:**
   - Перед добавлением новых ключей обязательно проверять существующие ключи в `Localizable.xcstrings`
   - Использовать существующие ключи там, где возможно (`Home.Activity`, `.workoutDay`, `.stretchDay`, `.restDay`, `.sickDay` и др.)
   - Добавлять новые ключи только если они специфичны для часов и не существуют в основном приложении

4. **Статус переводов:**
   - Все новые переводы должны иметь статус `"state" : "needs_review"`
   - Переводы добавляются на русский и английский языки

### Этап 1-6: Основная реализация ✅
- ✅ Настройка проекта, Codable модели, сервисы, ViewModels, интеграция с iPhone, UI экраны
- ⚠️ WCSessionDelegate для watchOS: НЕ добавлять методы `sessionDidBecomeInactive` и `sessionDidDeactivate` (unavailable на watchOS)
- [ ] Добавить недостающие локализованные строки (`Watch.Activity.*`, `Watch.Workout.*`)

### Этап 7: UI/UX оптимизация для часов

#### 7.1 Адаптация дизайна ✅ Частично выполнено
- ✅ Минималистичный дизайн, платформо-специфичные компоненты, системные цвета
- [ ] Оптимизация шрифтов для читаемости

#### 7.2 Обратная связь ✅
- ✅ Визуальная обратная связь, индикаторы загрузки, сообщения об ошибках

### Этап 8: Финальное тестирование и документация

#### 8.1-8.2 Тестирование ✅
- ✅ Исправлено 18+ unit-тестов, добавлено 18 интеграционных тестов

#### 8.3 UI-тесты (опционально)
- [ ] Тесты основных сценариев использования
- [ ] Тесты навигации между экранами
- [ ] Тесты выбора активности
- [ ] Тесты выполнения тренировки

#### 8.4 Тестирование на устройствах
- [ ] Тестирование на реальных часах (разные модели)
- [ ] Тестирование синхронизации между часами и iPhone
- [ ] Тестирование обработки ошибок при отсутствии связи с iPhone
- [ ] Тестирование производительности

#### 8.4.1 Анализ логов синхронизации ✅
- ✅ Функциональность работает корректно
- ⚠️ Выявлена избыточность: дублирование отправки `applicationContext` и `sendMessage` (см. раздел 8.6.1)

#### 8.4.2 Исправление багов, найденных при ручном тестировании

**Выполненные баги (1-6):** ✅
- ✅ Авторизация, обработка `currentDay` и `currentActivity`, синхронизация выбора/изменения/удаления активности

**Новые баги, найденные при тестировании:**

7. **При сохранении тренировки на часах как "пройденной" экран не закрывается и не все данные отправляются на iPhone** ✅ Исправлено
   - ✅ Закрытие экрана, индикатор загрузки, передача всех данных (`count`, `trainings`, `duration`, `executionType`, `comment`)

8. **При сохранении тренировки на iPhone данные не отправляются на часы или отправляются не полностью** ⚠️ Частично исправлено, требуется доработка
   - **Проблема:** При сохранении тренировки на iPhone:
     - ✅ Первичное сохранение активности типа `workout` передается на часы
     - ❌ При изменении параметров уже существующей активности `workout` для того же дня и сохранении обновление НЕ передается на часы
     - В логах часов приходит только `PHONE_COMMAND_AUTH_STATUS` с `currentActivity` и `currentDay`, но данные тренировки не обновляются
   - **Сценарии:**
     - Открытие `WorkoutPreviewScreen` на iPhone → нажатие "Сохранить как пройденную" → первичное сохранение работает
     - Редактирование существующей тренировки → изменение параметров → сохранение → обновление НЕ передается на часы
     - Прохождение всей тренировки на iPhone → нажатие "Сохранить" → обновление НЕ передается на часы
   - **Логи с часов при обновлении:**
     ```
     Получено сообщение от iPhone: ["command": PHONE_COMMAND_AUTH_STATUS, "isAuthorized": 1, "currentActivity": 0, "currentDay": 15]
     Получена команда изменения статуса авторизации: true
     Обновление статуса авторизации: true
     ```
   - **Ожидаемое поведение:**
     - После любого сохранения/обновления тренировки на iPhone должен отправляться `applicationContext` с обновленным `currentActivity`
     - Часы должны получать обновление и отображать актуальные данные тренировки
     - Должна быть синхронизация данных тренировки между iPhone и часами при любых изменениях

9-10. **Изменение количества кругов/подходов не работает при редактировании тренировки** ✅ Исправлено
   - Изменена логика `displayedCount` в `WorkoutPreviewViewModel` (iPhone и Watch): используется `plannedCount ?? count` (приоритет у `plannedCount`)
   - Также исправлена логика `buildWorkoutResult()` в Watch: `plannedCount ?? count ?? 0`
   - Обновлены unit-тесты для соответствия новой логике

11. **После сохранения тренировки на часах локальные данные не обновляются** ⚠️ Требует исправления
   - **Проблема:** После сохранения измененной тренировки на часах:
     - ✅ Данные успешно отправляются на iPhone (все параметры: `count`, `trainings`, `duration`, `executionType`, `comment`)
     - ✅ iPhone обрабатывает сохранение и отправляет обратно `PHONE_COMMAND_AUTH_STATUS` с обновленным `currentActivity`
     - ❌ На часах локальные данные НЕ обновляются - остаются старые данные (стандартные данные для этого дня)
     - ❌ На главном экране часов отображаются стандартные данные тренировки, как если бы использовался `WorkoutProgramCreator` с базовыми упражнениями для этого дня
   - **Сценарии:**
     - **Сценарий 1:** Редактирование тренировки на часах
       - Открыт экран редактирования тренировки (`WorkoutPreviewView`)
       - Внесены изменения (добавлено упражнение, изменено количество повторов)
       - Нажата кнопка "Сохранить"
       - Данные успешно отправлены на iPhone
       - ❌ На часах на главном экране остались старые данные (стандартные для этого дня)
     - **Сценарий 2:** Редактирование тренировки, ранее сохраненной на iPhone
       - На iPhone сохранена активность `workout` - на часы успешно передаются все параметры тренировки
       - На часах изменена эта тренировка (добавлены/изменены упражнения)
       - Нажата кнопка "Сохранить"
       - На iPhone передаются актуальные данные
       - ❌ На часах остаются старые данные (те же, что были при первом сохранении на iPhone)
   - **Логи с часов при сохранении:**
     ```
     Отправка результата тренировки на iPhone: день 15, количество 4, упражнений 3
     Получено сообщение от iPhone: ["currentDay": 15, "isAuthorized": 1, "currentActivity": 0, "command": PHONE_COMMAND_AUTH_STATUS]
     Получена команда изменения статуса авторизации: true
     Обновление статуса авторизации: true
     Результат тренировки успешно отправлен на iPhone
     Тренировка для дня 15 сохранена
     ```
   - **Ожидаемое поведение:**
     - После успешного сохранения тренировки на часах локальные данные должны обновляться актуальными значениями
     - На главном экране часов должны отображаться актуальные данные тренировки (с учетом всех изменений)
     - Должна быть синхронизация локальных данных на часах после успешного сохранения
     - Возможные решения:
       - Обновить локальные данные в `WorkoutPreviewViewModel` после успешного сохранения
       - Запросить обновленные данные с iPhone после сохранения через `requestWorkoutData`
       - Обновить данные в `HomeViewModel` после получения `PHONE_COMMAND_AUTH_STATUS` с обновленным `currentActivity`

**План исправления:**

1. **Рефакторинг `WorkoutPreviewScreen` (iPhone):**
   - ✅ **Убрать лишний код в `onWorkoutCompleted` (строки 50-63):** Выполнено
     - Удалена отправка данных на часы после завершения тренировки в `onWorkoutCompleted`
     - Отправка данных на часы происходит только после фактического сохранения (когда пользователь нажал кнопку "Сохранить")
   
   - ❌ **Оптимизировать отправку данных на часы после сохранения (строки 219-227):**
     - Не обращаться к `activitiesService.getActivityType()` для получения данных о тренировке
     - У нас есть `viewModel`, в котором есть все данные для тренировки
     - Доработать метод `viewModel.saveTrainingAsPassed()`, чтобы он возвращал в случае успеха данные для этой активности (`DayActivityType?`)
     - Использовать возвращаемое значение из `saveTrainingAsPassed()` вместо обращения к `activitiesService`

2. **Доработка `WorkoutPreviewViewModel.saveTrainingAsPassed()` (iPhone):**
   - Изменить сигнатуру метода: `func saveTrainingAsPassed(...) -> DayActivityType?`
   - Метод должен возвращать `DayActivityType?` в случае успешного сохранения
   - Возвращать `nil` в случае ошибки или если активность не была сохранена
   - Это позволит использовать данные из ViewModel вместо повторного обращения к `activitiesService`

3. **Рефакторинг логики декодирования данных команды `saveWorkout`:**
   - ❌ Вынести логику декодирования данных и создания `WorkoutProgramCreator` из `StatusManager.handleSaveWorkoutCommand()` (строки 469-510) в статический метод расширения `WatchStatusMessage`
   - Создать метод типа `static func parseSaveWorkoutData(_ data: [String: Any]) throws -> (creator: WorkoutProgramCreator, duration: Int?)`
   - Метод должен:
     - Декодировать `day`, `result` (WorkoutResult), `executionType`, `trainings` (массив WorkoutPreviewTraining), `comment` из словаря `data`
     - Создать и вернуть готовый объект `WorkoutProgramCreator` с декодированными данными (plannedCount будет вычислен автоматически, если nil)
     - Вернуть `duration` из `WorkoutResult.duration` для последующей установки в `DayActivity`
   - Выбрасывать ошибки при неверном формате данных
   - Обновить `StatusManager.handleSaveWorkoutCommand()` для использования нового метода (упростит код, убрав декодирование и создание `WorkoutProgramCreator`)
   - Обновить тесты для проверки нового метода декодирования и создания `WorkoutProgramCreator`

4. **Обновление локальных данных на часах после сохранения:**
   - После успешного сохранения тренировки на часах обновить локальные данные в `WorkoutPreviewViewModel`
   - Обновить данные в `HomeViewModel` после получения `PHONE_COMMAND_AUTH_STATUS` с обновленным `currentActivity`
   - Запросить обновленные данные с iPhone через `requestWorkoutData` после успешного сохранения (опционально)

5. **Тестирование:**
   - Написать unit-тесты для проверки возврата данных из `saveTrainingAsPassed()`
   - Написать unit-тесты для проверки обновления локальных данных на часах после сохранения
   - Обновить тесты для проверки нового метода `WatchStatusMessage.parseSaveWorkoutData()`
   - Протестировать на реальных устройствах

**Файлы для проверки и изменения:**
- `SwiftUI-SotkaApp/Screens/WorkoutPreview/WorkoutPreviewScreen.swift` - ✅ убрать лишний код в `onWorkoutCompleted` (выполнено), оптимизировать отправку данных после сохранения
- `SwiftUI-SotkaApp/Screens/WorkoutPreview/WorkoutPreviewViewModel.swift` - доработать `saveTrainingAsPassed()` для возврата `DayActivityType?`
- `SwiftUI-SotkaApp/Services/WatchStatusMessage.swift` - добавить статический метод `parseSaveWorkoutData()` для декодирования данных команды `saveWorkout`
- `SwiftUI-SotkaApp/Services/StatusManager.swift` - использовать новый метод `WatchStatusMessage.parseSaveWorkoutData()` в `handleSaveWorkoutCommand()`
- `SwiftUI-SotkaAppTests/StatusManagerTests/StatusManagerWatchConnectivityTests.swift` - обновить тесты для проверки нового метода декодирования
- `SotkaWatch Watch App/ViewModels/WorkoutPreviewViewModel.swift` - обновление локальных данных после сохранения
- `SotkaWatch Watch App/ViewModels/HomeViewModel.swift` - обновление данных после получения `PHONE_COMMAND_AUTH_STATUS`

**Примечания:**
- Все тесты должны следовать правилам из `unit-testing-ios-app.mdc`
- Использовать моки для `WCSession` и других зависимостей
- Тесты должны быть на русском языке в аннотации `@Test`
- Использовать `#expect` и `#require` вместо force unwrap

#### 8.4.3 План исправления багов синхронизации тренировок

**Приоритет:** Высокий (критично для работы функционала тренировок)

**Баг 7: Сохранение тренировки на часах** ✅ Исправлено
- ✅ Все данные передаются, включая `trainings`, экран закрывается, индикатор загрузки работает

**Баг 8: Сохранение тренировки на iPhone не отправляет данные на часы или отправляется не полностью**

**Статус:** ⚠️ Частично исправлено
- ✅ Отправка данных на часы после первичного сохранения и завершения тренировки (исправлено)
- ❌ При изменении параметров уже существующей активности `workout` обновление НЕ передается на часы - требуется исправление

**План исправления:**
1. **Найти место обновления существующей активности:**
   - Проверить `WorkoutPreviewScreen` - метод сохранения после редактирования существующей тренировки
   - Проверить `DailyActivitiesService.createDailyActivity()` - вызывается ли отправка при обновлении существующей активности
   - Проверить, вызывается ли `sendCurrentStatus()` при обновлении существующей активности через `saveTrainingAsPassed()`

2. **Добавить отправку данных на часы:**
   - Добавить вызов `sendCurrentStatus()` при обновлении существующей активности
   - Проверить, что данные тренировки (`count`, `duration`) включены в синхронизацию

3. **Проверить обработку на часах:**
   - Убедиться, что часы обрабатывают обновление `currentActivity` из `applicationContext`
   - Проверить обновление отображения активности дня на часах
   - Добавить логирование получения данных на часах

4. **Тестирование:**
   - Написать unit-тесты для проверки отправки данных после сохранения
   - Написать интеграционные тесты для проверки синхронизации
   - Протестировать на реальных устройствах

**Общий план действий:**

1. **Исправить баг 7 (сохранение на часах):** ✅ Исправлено

2. **Исправить баг 8 (сохранение на iPhone):**
   - ✅ Отправка `applicationContext` после первичного сохранения и завершения тренировки (исправлено)
   - ❌ Добавить отправку `applicationContext` при обновлении существующей активности - требуется исправление
   - Найти место, где обновляется существующая активность и добавить отправку на часы
   - Написать тесты для проверки отправки обновлений

3-4. **Исправить баги 9-10 (plannedCount на часах и iPhone):** ✅ Исправлено
   - Изменена логика `displayedCount`: `plannedCount ?? count` (приоритет у `plannedCount`)
   - Исправлена логика `buildWorkoutResult()` в Watch: `plannedCount ?? count ?? 0`
   - Обновлены unit-тесты

5. **Исправить баг 11 (обновление локальных данных на часах после сохранения):**
   - ✅ Убрать лишний код в `WorkoutPreviewScreen.onWorkoutCompleted` (отправка данных на часы до сохранения) - выполнено
   - Доработать `WorkoutPreviewViewModel.saveTrainingAsPassed()` для возврата `DayActivityType?`
   - Оптимизировать отправку данных на часы после сохранения (использовать данные из ViewModel вместо `activitiesService`)
   - Вынести логику декодирования данных команды `saveWorkout` в статический метод расширения `WatchStatusMessage`
   - Обновить локальные данные на часах после успешного сохранения
   - Написать тесты

6. **Интеграционное тестирование:**
   - Протестировать полный цикл: сохранение на часах → синхронизация с iPhone (включая `trainings`)
   - Протестировать полный цикл: сохранение на iPhone → синхронизация с часами (включая обновление существующей активности)
   - Протестировать редактирование `plannedCount` на часах и iPhone
   - Проверить все сценарии сохранения и редактирования тренировки

6. **Оптимизация (опционально):**
   - После исправления багов можно приступить к оптимизации избыточности событий (раздел 8.6.1)

**Баг 9: Изменение plannedCount через WorkoutStepperView не сохраняется на WorkoutPreviewView (часы)**

**Анализ проблемы:**
1. При редактировании ранее пройденной тренировки на часах открывается `WorkoutPreviewView`
2. При изменении `plannedCount` через `WorkoutStepperView` значение не обновляется на экране `WorkoutPreviewView` после возврата
3. Изменение `count` для конкретного упражнения работает корректно
4. Проблема специфична для `plannedCount` (количество подходов/кругов)

**План исправления:**
1. **Проверить Binding для plannedCount:**
   - Убедиться, что `Binding` в `WorkoutPreviewView.makePlannedCountView()` правильно связан с `viewModel.plannedCount`
   - Проверить метод `updatePlannedCount(for:)` в `WorkoutPreviewViewModel`
   - Проверить, что изменения из `WorkoutStepperView` корректно передаются в ViewModel

2. **Проверить обновление UI:**
   - Убедиться, что `WorkoutPreviewView` реагирует на изменения `plannedCount` в ViewModel
   - Проверить использование `@Observable` и обновление computed property `displayedCount`
   - Добавить логирование изменений для отладки

3. **Проверить различие между count и plannedCount:**
   - Выяснить, почему изменение `count` для упражнений работает, а `plannedCount` - нет
   - Проверить различия в обработке Binding для этих значений

4. **Тестирование:**
   - Написать unit-тесты для проверки обновления `plannedCount` через `WorkoutStepperView`
   - Протестировать на реальных часах после исправления

**Файлы для проверки и изменения:**
- `SotkaWatch Watch App/ViewModels/WorkoutPreviewViewModel.swift` - методы обновления `plannedCount`
- `SotkaWatch Watch App/Views/WorkoutPreviewView.swift` - Binding для `plannedCount` в `makePlannedCountView()`
- `SotkaWatch Watch App/Views/WorkoutStepperView.swift` - передача изменений обратно в ViewModel

**Баг 10: Изменение plannedCount не работает в iPhone приложении при редактировании тренировки**

**Анализ проблемы:**
1. При редактировании тренировки в iPhone приложении открывается `WorkoutPreviewScreen`
2. При изменении `plannedCount` кнопки + и - не меняют значение
3. Значение `plannedCount` остается неизменным при нажатии на кнопки
4. Остальные функции редактирования работают корректно (изменение `count` для упражнений, комментарий)

**План исправления:**
1. **Проверить Binding для plannedCount:**
   - Убедиться, что `Binding` в `WorkoutPreviewScreen.makePlannedCountView()` правильно связан с `viewModel.plannedCount`
   - Проверить метод `updatePlannedCount(id:action:)` в `WorkoutPreviewViewModel` для iPhone
   - Проверить, что обработчик `onAction` в `TrainingRowView` корректно вызывает метод ViewModel

2. **Проверить обработку действий:**
   - Убедиться, что при нажатии + и - для `plannedCount` вызывается правильный метод ViewModel
   - Проверить, что `id == "plannedCount"` корректно обрабатывается в `updatePlannedCount(id:action:)`
   - Добавить логирование изменений для отладки

3. **Проверить обновление UI:**
   - Убедиться, что `WorkoutPreviewScreen` реагирует на изменения `plannedCount` в ViewModel
   - Проверить использование `@Observable` и обновление computed property `displayedCount`
   - Сравнить с работой изменения `count` для упражнений (которое работает)

4. **Тестирование:**
   - Написать unit-тесты для проверки обновления `plannedCount` в iPhone приложении
   - Протестировать на реальном устройстве после исправления

**Файлы для проверки и изменения:**
- `SwiftUI-SotkaApp/Screens/WorkoutPreview/WorkoutPreviewViewModel.swift` - методы обновления `plannedCount`
- `SwiftUI-SotkaApp/Screens/WorkoutPreview/WorkoutPreviewScreen.swift` - Binding для `plannedCount` в `makePlannedCountView()`
- `SwiftUI-SotkaApp/Screens/WorkoutPreview/Views/TrainingRowView.swift` - обработчик действий для кнопок + и -

**Файлы для проверки и изменения (баги 7-8, 11):**
- `SotkaWatch Watch App/ViewModels/WorkoutPreviewViewModel.swift` - сохранение на часах, передача `trainings`, индикатор загрузки, обновление локальных данных после сохранения
- `SotkaWatch Watch App/Views/WorkoutPreviewView.swift` - отображение индикатора загрузки во время сохранения
- `SotkaWatch Watch App/Services/WatchConnectivityService.swift` - отправка данных с часов, формат команды `WATCH_COMMAND_SAVE_WORKOUT`
- `SotkaWatch Watch App/ViewModels/HomeViewModel.swift` - обновление данных после получения `PHONE_COMMAND_AUTH_STATUS`
- `SwiftUI-SotkaApp/Services/StatusManager.swift` - обработка команды сохранения на iPhone, обработка `trainings`
- `SwiftUI-SotkaApp/Screens/WorkoutPreview/WorkoutPreviewScreen.swift` - сохранение на iPhone, отправка обновлений, ✅ убрать лишний код в `onWorkoutCompleted` (выполнено), оптимизировать отправку данных после сохранения
- `SwiftUI-SotkaApp/Screens/WorkoutPreview/WorkoutPreviewViewModel.swift` - доработать `saveTrainingAsPassed()` для возврата `DayActivityType?`
- `SwiftUI-SotkaApp/Screens/Workout/WorkoutScreen.swift` - сохранение после прохождения
- `SwiftUI-SotkaApp/Services/DailyActivitiesService.swift` - сохранение активности, отправка обновлений на часы
- `SwiftUI-SotkaApp/Models/SWSharedModels/WorkoutProgramCreator.swift` - создание `DayActivity` с полным списком упражнений

#### 8.5 Документация
- [ ] Обновление `feature-map.md` с информацией о часах
- [ ] Создание документации по архитектуре часов (если нужно)
- [ ] Документация API WatchConnectivity
- [ ] Инструкции по тестированию

#### 8.6 Оптимизация

##### 8.6.1 Оптимизация синхронизации между iPhone и часами ⚠️ Требует оптимизации

**Проблемы:** Дублирование отправки `applicationContext` и `sendMessage`, множественные сообщения при изменении активности, избыточные запросы при запуске

**Рекомендации по оптимизации:**

1. **Убрать дублирование отправки:**
   - `applicationContext` должен быть основным механизмом синхронизации (работает даже когда приложение закрыто)
   - `sendMessage` с PHONE_COMMAND_AUTH_STATUS должен использоваться только для немедленной синхронизации, когда приложение активно
   - Рассмотреть возможность отправки `sendMessage` только если `applicationContext` не был успешно доставлен

2. **Оптимизировать обработку на часах:**
   - На часах `handleReceivedMessage()` для PHONE_COMMAND_AUTH_STATUS может игнорироваться, если данные уже получены через `applicationContext`
   - Или обрабатывать только если `applicationContext` не содержит актуальных данных

3. **Уменьшить количество сообщений:**
   - При изменении активности отправлять только `applicationContext` (не отправлять `sendMessage`)
   - `sendMessage` использовать только для критичных обновлений или когда `applicationContext` недоступен

4. **Исправить двойную проверку applicationContext:**
   - Убрать лишнюю проверку "Application context data is nil" при запуске часов
   - Проверять `receivedApplicationContext` только один раз при активации WCSession

**Приоритет оптимизации:**
- Средний: функциональность работает корректно, но есть избыточность
- Оптимизация улучшит производительность и уменьшит количество логов
- Не критично для работы приложения, но желательно для чистоты кода

**План оптимизации (опционально, после завершения основной функциональности):**

1. Рефакторинг `sendCurrentStatus()`:
   - Разделить логику отправки `applicationContext` и `sendMessage`
   - Отправлять `sendMessage` только при необходимости (например, если `applicationContext` не был доставлен)

2. Оптимизация обработки на часах:
   - Добавить проверку в `handleReceivedMessage()` для PHONE_COMMAND_AUTH_STATUS: игнорировать, если данные уже получены через `applicationContext`

3. Уменьшение количества сообщений:
   - При изменении активности отправлять только `applicationContext`
   - `sendMessage` использовать только для критичных обновлений

4. Исправление двойной проверки:
   - Убрать лишнюю проверку "Application context data is nil"

- [ ] Оптимизация размера приложения
- [ ] Оптимизация производительности
- [ ] Оптимизация энергопотребления

#### 8.7 Финальная проверка

##### 8.7.1 Проверка синхронизации ⚠️

**Результаты:** ✅ Синхронизация активностей работает корректно
⚠️ Выявлены баги тренировок (см. раздел 8.4.3), избыточность логов (см. раздел 8.6.1)

- [ ] Проверка всех функций
- [ ] Проверка обработки ошибок при отсутствии связи с iPhone
- [ ] Проверка на разных моделях часов
- [ ] Проверка локализации (русский и английский)
- [ ] Проверка логирования (русский язык)
- [ ] Проверка безопасного извлечения опционалов (нет force unwrap)
- [x] ✅ Проверка компиляции для watchOS: UIKit API исключены из компиляции, платформо-специфичные компоненты корректно обернуты в условную компиляцию

## Технические детали

### Модели данных

#### Модели с Codable для передачи данных

**Модели с Codable:**
- `WorkoutResult` - результат тренировки (count, duration)
- `WorkoutPreviewTraining` - данные упражнения в тренировке
- `WorkoutData` - данные тренировки (day, executionType, trainings, plannedCount)
- `WorkoutDataResponse` - полные данные тренировки с iPhone (workoutData, executionCount, comment)

**Примечание:**
- Простые структуры получают Codable для передачи через WatchConnectivity, enum'ы передаются через rawValue (Int)
- Модели размещены в общих моделях (`Models/SWSharedModels/`) или добавлены в Watch App target

### Команды WatchConnectivity

```swift
extension Constants {
    /// Команды для обмена данными между часами и iPhone через WatchConnectivity
    enum WatchCommand: String {
        // От часов к iPhone
        case setActivity = "WATCH_COMMAND_SET_ACTIVITY"
        case saveWorkout = "WATCH_COMMAND_SAVE_WORKOUT"
        case getCurrentActivity = "WATCH_COMMAND_GET_CURRENT_ACTIVITY"
        case getWorkoutData = "WATCH_COMMAND_GET_WORKOUT_DATA"
        case deleteActivity = "WATCH_COMMAND_DELETE_ACTIVITY"
        
        // От iPhone к часам
        case currentActivity = "PHONE_COMMAND_CURRENT_ACTIVITY"
        case sendWorkoutData = "PHONE_COMMAND_SEND_WORKOUT_DATA"
        case currentStatus = "PHONE_COMMAND_CURRENT_STATUS"
    }
}
```

**Примечание:** Enum `Constants.WatchCommand` находится в файле `SwiftUI-SotkaApp/Models/SWSharedModels/Constants.swift` и доступен обоим таргетам (основному приложению и Watch App).

### Формат сообщений WatchConnectivity

**Установка активности:**
```json
{
    "command": "WATCH_COMMAND_SET_ACTIVITY",
    "day": 42,
    "activityType": 0
}
```

**Сохранение тренировки:**
```json
{
    "command": "WATCH_COMMAND_SAVE_WORKOUT",
    "day": 42,
    "result": {"count": 4, "duration": 1800},
    "executionType": 0,
    "trainings": [...],
    "comment": "Отличная тренировка!"
}
```

**Удаление активности:**
```json
{
    "command": "WATCH_COMMAND_DELETE_ACTIVITY",
    "day": 42
}
```

**Примечание:** 
- Команды проверки авторизации и получения/обновления текущего дня объединены в `PHONE_COMMAND_CURRENT_STATUS` - данные передаются вместе (статус авторизации, текущий день и текущая активность)
- Команды для получения данных пользователя не нужны - часы не отображают данные пользователя

**Ответ с текущей активностью дня:**
```json
{
    "command": "PHONE_COMMAND_CURRENT_ACTIVITY",
    "day": 42,
    "activityType": 0,
    "count": null,
    "duration": null
}
```

**Уведомление об изменении статуса (через `sendMessage`):**
```json
{
    "command": "PHONE_COMMAND_CURRENT_STATUS",
    "isAuthorized": true,
    "currentDay": 42,
    "currentActivity": 0
}
```
*Примечания:*
- Команда отправляется через `sendMessage` при авторизации/логауте или изменении `currentDayCalculator`
- `isAuthorized: Bool` - обязательное поле (статус авторизации)
- `currentDay: Int?` - обязательное поле, если `isAuthorized == true`, иначе `null`
- `currentActivity: Int?` - опциональное поле (тип активности текущего дня, если активность выбрана)
- Часы получают данные только через WatchConnectivity, локальное хранение не используется

**Важно:** ✅ Синхронизация через `sendMessageToWatch`, данные только из `WatchConnectivityService`, при отсутствии связи показывается `AuthRequiredView`

## Риски и митигация

### Риски и митигация

**Решенные риски (1, 5-7):** ✅ Обработка ошибок, авторизация, синхронизация через WatchConnectivity

**Активные риски:**
- **Риск 2:** Различия в данных - iPhone как источник истины
- **Риск 3:** Производительность - оптимизация кода, минимальное использование ресурсов
- **Риск 4:** Сложность синхронизации - простая архитектура, четкие команды

## Приоритеты разработки

### Приоритеты разработки

**Высокий и средний приоритет:** ✅ Выполнено (MVP, выполнение тренировки, синхронизация)

### Низкий приоритет (будущие улучшения)
1. Расширенная статистика тренировок
2. Интеграция с HealthKit
3. Уведомления о тренировках
4. Циферблаты с данными программы

## Отличия от реализации в старом приложении (SOTKA-OBJc)

Этот раздел описывает ключевые отличия планируемой реализации в новом приложении от реализации в старом приложении SOTKA-OBJc.

### Архитектура хранения данных

**Старое приложение (SOTKA-OBJc):**
- Часы используют **CoreData** для локального хранения данных
- Модели: `WatchDbDay`, `WatchDbTraining`, `WatchDbCustomExercise`, `WatchDbSettings`
- Данные сохраняются локально на часах с флагом `synched` для отслеживания синхронизации
- Двусторонняя синхронизация: часы работают независимо, синхронизируются периодически
- Очередь несинхронизированных данных на часах

**Новое приложение (текущее состояние):**
- Часы не хранят данные локально - все данные получаются только через WatchConnectivity в реальном времени
- iPhone - единственное хранилище данных (SwiftData), часы работают как клиент
- Синхронизация только через WatchConnectivity (`sendMessage`), при отсутствии связи показывается `AuthRequiredView`

### Формат передачи данных

**Старое приложение:**
- Используются **JSON строки** (NSString) в Dictionary
- Команды передаются как **числовые константы** (enum WATCH_COMMANDS: 0, 1, 2...)
- Данные сериализуются в JSON строку через `toJSONString()`
- Пример: `@{@"command": @"0", @"days": jsonString}`

**Новое приложение:**
- Используются **модели с Codable** для прямой передачи данных (без DTO)
- Команды передаются как **строковые enum** (WatchCommand: "WATCH_COMMAND_GET_TRAIN_LIST")
- Данные сериализуются через JSONEncoder/JSONDecoder
- Пример: `{"command": "WATCH_COMMAND_SAVE_WORKOUT", "result": {...}}`

### Команды WatchConnectivity

**Старое приложение:**
- `WATCH_COMMAND_GET_TRAIN_LIST` (0) - запрос данных тренировки
- `WATCH_COMMAND_SAVE_TRAININGS` (1) - сохранение тренировок (массив дней)
- `PHONE_COMMAND_UPDATE_CURRENT_DAY` (2) - обновление текущего дня
- `PHONE_SYNC_REQUEST` (3) - запрос синхронизации
- `PHONE_COMMAND_GET_UNSYNCED_TRAININGS` (4) - запрос несинхронизированных тренировок

**Новое приложение:**
- Расширенный набор команд с явными названиями, более детальное разделение команд (отдельно для активности и тренировки)
- Команды проверки авторизации не нужны - статус передается через WatchConnectivity (`sendMessage`)

### Авторизация

**Старое приложение:**
- Не видно явной проверки авторизации при запуске часов
- Часы могут работать без явной проверки статуса авторизации

**Новое приложение:**
- Обязательная проверка авторизации при запуске, блокировка функционала, экран `AuthRequiredView`
- Статус авторизации передается через WatchConnectivity

### Обработка данных тренировки

**Старое приложение:**
- Данные тренировки передаются как `WatchObject` (JSON строка)
- Сохранение тренировок происходит пакетами (массив дней)
- Локальное сохранение на часах перед синхронизацией

**Новое приложение:**
- Данные тренировки передаются через модели с Codable (`WorkoutData`, `WorkoutResult`)
- Сохранение по одной активности/тренировке, немедленная передача в iPhone без локального сохранения

### Синхронизация

**Старое приложение:**
- Двусторонняя синхронизация с флагом `synched`
- Часы могут работать офлайн с последующей синхронизацией
- Очередь несинхронизированных данных на часах
- iPhone может запрашивать несинхронизированные данные с часов

**Новое приложение:**
- Односторонняя передача данных: часы → iPhone (для сохранения)
- Часы запрашивают данные с iPhone в реальном времени, нет очереди синхронизации
- При отсутствии связи показывается ошибка, действия не выполняются

### Технологии

**Старое приложение:**
- Objective-C
- CoreData на часах
- UIKit для часов (WatchKit)
- JSON строки для передачи данных

**Новое приложение:**
- Swift 6.0
- SwiftData на iPhone (не используется на часах)
- SwiftUI для часов
- Codable модели для прямой передачи данных (без DTO)

### Преимущества нового подхода

1. **Упрощенная архитектура:**
   - Нет дублирования данных между часами и iPhone
   - Нет конфликтов данных
   - Проще поддержка и отладка

2. **Актуальность данных:**
   - Данные всегда актуальны (запрашиваются в реальном времени)
   - Нет рассинхронизации между устройствами

3. **Безопасность:**
   - Обязательная проверка авторизации
   - Данные хранятся только на iPhone

4. **Современные технологии:**
   - SwiftUI вместо WatchKit
   - SwiftData вместо CoreData
   - Codable модели вместо ручной сериализации JSON и DTO

### Недостатки нового подхода

1. **Зависимость от связи:**
   - Часы не могут работать полностью офлайн
   - Требуется постоянная связь с iPhone для работы

2. **Производительность:**
   - Каждый запрос требует связи с iPhone
   - Может быть медленнее при плохой связи

3. **Ограничения:**
   - Меньше автономности часов
   - Зависимость от доступности iPhone

## Рефакторинг архитектуры WatchConnectivity

**Важно:** Рефакторинг выполняется с соблюдением правил TDD (Test-Driven Development) и unit-тестирования:
- **TDD цикл**: Красный (тест падает) → Зеленый (код проходит тест) → Рефакторинг
- **Итеративный процесс**: Тест → Код → `make format` → `make test` → Следующий тест
- **Технологии**: Swift Testing (`import Testing`), `@Test`, `#expect`, `#require`
- **Моки**: Использование моков для всех зависимостей (WCSession, сервисы)
- **Описания тестов**: Все тесты с описанием на русском языке в аннотации `@Test`

### Рефакторинг архитектуры WatchConnectivity ✅ Выполнено
- ✅ Упрощение кода (~200 строк), улучшение архитектуры, безопасность, производительность

### Риски и митигация

#### Риск 1: Проблемы с actor isolation

**Проблема:** Делегат WCSession `nonisolated`, а обработка команд требует `@MainActor`

**Митигация:**
- Использовать `Task { @MainActor in }` для перехода в MainActor
- Использовать `nonisolated(unsafe)` для безопасного доступа к данным
- Тестировать на разных сценариях

#### Риск 2: Потеря команд при быстрых запросах

**Проблема:** При быстрых запросах команды могут обрабатываться не в том порядке

**Митигация:**
- WatchConnectivity гарантирует порядок доставки сообщений
- Если нужна гарантия порядка - добавить последовательную обработку через Actor
- Тестировать сценарии с множественными запросами

#### Риск 3: Регрессии в существующем функционале

**Проблема:** При рефакторинге может сломаться существующий функционал

**Митигация:**
- Пошаговый рефакторинг с тестами на каждом шаге
- Сохранение существующих тестов до завершения рефакторинга
- Тщательное тестирование на реальных устройствах


## Заключение

Этот план описывает разработку приложения для Apple Watch с сокращенным функционалом. Основные компоненты: авторизация, получение текущего дня, запрос данных с iPhone, сохранение через iPhone, главный экран, выбор активности, выполнение тренировки.

**Ключевые принципы:**
- iPhone - единственное хранилище данных (SwiftData), часы работают как клиент
- Обязательная авторизация, синхронизация через WatchConnectivity (`sendMessageToWatch`)
- Данные на часах получаются только через `WatchConnectivityService`, при отсутствии связи показывается `AuthRequiredView`

