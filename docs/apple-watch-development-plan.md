# План разработки приложения для Apple Watch

## Обзор

Этот документ описывает детальный план разработки приложения для Apple Watch с сокращенным функционалом по сравнению с основным iOS-приложением. Приложение для часов будет поддерживать выбор типа активности на день и выполнение тренировок с синхронизацией данных между часами и iPhone.

## Цели и ограничения

### Функционал для часов
- Выбор типа активности на сегодняшний день из 4 вариантов (`DayActivityType`):
  - `workout` - тренировка
  - `stretch` - растяжка
  - `rest` - отдых
  - `sick` - болезнь
- Выполнение тренировки (если выбран тип `workout`):
  - Упрощенный интерфейс выполнения тренировки
  - Сохранение результата тренировки
- Синхронизация данных между часами и iPhone:
  - Двусторонняя синхронизация через WatchConnectivity
  - Синхронизация выбранных активностей
  - Синхронизация результатов тренировок
  - Синхронизация текущего дня программы

### Ограничения
- Минимальный UI для часов (ограниченный размер экрана)
- Упрощенная логика тренировок (без сложных настроек)
- **Часы не хранят данные локально** - все данные запрашиваются с iPhone и сохраняются через iPhone в SwiftData
- **Статус авторизации и `startDate`** читаются напрямую из App Group UserDefaults (см. раздел 1.3)
- **Текущий день** вычисляется локально на часах из `startDate` с помощью `DayCalculator`
- **iPhone приложение является единственным хранилищем данных** (SwiftData)
- **Приложение для часов работает только после успешной авторизации в iPhone приложении**

## Архитектура

### Структура проекта

```
SotkaWatch Watch App/
├── Models/
│   └── AuthState.swift                 # Модель состояния авторизации для Watch App ✅
├── Views/
│   ├── AuthRequiredView.swift          # Экран для неавторизованных пользователей ✅
│   ├── HomeView.swift                  # Главный экран часов ✅
│   ├── DayActivityView.swift           # Экран активности дня (выбор/отображение) ✅
│   ├── DayActivitySelectionView.swift  # Выбор типа активности ✅
│   ├── SelectedActivityView.swift      # Отображение выбранной активности ✅
│   ├── WorkoutView.swift               # Экран выполнения тренировки (еще не создан)
│   └── WorkoutRestTimerView.swift      # Таймер отдыха между кругами/подходами (еще не создан)
└── Utilities/
    └── WatchAppGroupHelper.swift       # Утилита для работы с App Group UserDefaults ✅

Примечание: 
- Модели данных используются из основного приложения:
  - Models/SWSharedModels/WorkoutData.swift (общая модель для передачи данных тренировки)
  - Models/Workout/WorkoutResult.swift (добавлен Codable для передачи через WatchConnectivity)
  - Models/Workout/WorkoutPreviewTraining.swift (добавлен Codable для передачи через WatchConnectivity)
  - Models/Workout/DayActivityType.swift (используется rawValue для передачи)
  - Models/Workout/ExerciseExecutionType.swift (используется rawValue для передачи)
  - Models/Workout/ExerciseType.swift (добавлен в Watch App target для использования локализованных названий и иконок упражнений)
- Локальные модели для Watch App размещаются в `Models/` (например, `AuthState`)
- Простые структуры (не SwiftData) получают Codable для прямой передачи через WatchConnectivity
- Модели с `@Model` (SwiftData) не используются напрямую на часах
- Ассеты упражнений находятся в отдельном `ExercisesAssets.xcassets`, доступном обоим таргетам (основное приложение и Watch App)
```

### Технологии

- **SwiftUI** - для UI (watchOS поддерживает SwiftUI)
- **WatchConnectivity** - для связи с iPhone
- **UserDefaults** (App Group) - для чтения статуса авторизации и `startDate` (см. раздел 1.3)
- **DayCalculator** - модель для вычисления текущего дня программы (переиспользуется из основного приложения)
- **OSLog** - для логирования

**Важно:** 
- Часы не используют SwiftData или другое постоянное хранилище. Все данные запрашиваются с iPhone в реальном времени.
- **Модели переиспользуются из основного приложения** - не создаем дубликаты моделей для часов.
- **Простые структуры (не SwiftData)** получают Codable для прямой передачи через WatchConnectivity:
  - `WorkoutResult` - добавлен Codable
  - `WorkoutPreviewTraining` - добавлен Codable
  - `DayActivityType` и `ExerciseExecutionType` - используют rawValue для передачи
- **`ExerciseType`** добавлен в Watch App target для использования локализованных названий упражнений и иконок на экране тренировки
- **Ассеты упражнений** находятся в отдельном `ExercisesAssets.xcassets`, доступном обоим таргетам (основное приложение и Watch App), что позволяет использовать иконки упражнений без дублирования
- Модели с `@Model` (SwiftData) не используются напрямую на часах, только для преобразования в простые структуры.

### Обмен данными между часами и iPhone

#### WatchConnectivity Service

**Архитектура связи:**
- **iPhone является единственным хранилищем данных** (SwiftData)
- **Часы не хранят данные локально** - все данные запрашиваются с iPhone в реальном времени
- **Все действия с часов передаются в iPhone** для сохранения в SwiftData
- Связь выполняется через WatchConnectivity Framework
- **Чтение статуса авторизации и `startDate`** напрямую из App Group UserDefaults (см. раздел 1.3)
- **Текущий день** вычисляется локально на часах из `startDate` с помощью `DayCalculator`
- **Уведомления об изменениях статуса авторизации:**
  - iPhone отправляет команду `PHONE_COMMAND_AUTH_STATUS_CHANGED` при успешной авторизации или логауте
  - Часы также проверяют статус авторизации при активации приложения (`scenePhase == .active`) для обеспечения актуальности данных даже при отсутствии связи

**Команды синхронизации:** (см. раздел "Команды WatchConnectivity" ниже)

**Формат данных:**
- JSON для передачи сложных структур
- Простые типы (Int, String, Bool) для простых команд

#### Разрешение конфликтов при одновременном изменении активности

**Проблема:**
При одновременном изменении активности на один и тот же день с разных устройств (часы и iPhone) могут возникать конфликты. Например:
- На iPhone начали тренировку (создана активность `.workout`), но не закончили и свернули приложение
- На часах выбрали активность "отдых" для того же дня
- Без специальной обработки активность будет перезаписана на "отдых", что приведет к потере данных о тренировке

**Стратегия разрешения конфликтов:**

1. **Приоритет незавершенных тренировок:**
   - Если на день уже существует активность типа `.workout` (тренировка), изменение на другой тип активности (`.rest`, `.stretch`, `.sick`) должно быть запрещено или требовать подтверждения
   - Это предотвращает случайную потерю данных о начатой тренировке
   - Проверка выполняется на iPhone при обработке команды `WATCH_COMMAND_SET_ACTIVITY` от часов

2. **Last Write Wins (LWW) для других случаев:**
   - Для активностей типа `.rest`, `.stretch`, `.sick` применяется стратегия LWW на основе `modifyDate`
   - Последнее изменение побеждает (обновляется `modifyDate` при каждом изменении)
   - Это соответствует существующей логике разрешения конфликтов при синхронизации с сервером

3. **Проверка перед изменением:**
   - При получении команды `WATCH_COMMAND_SET_ACTIVITY` на iPhone:
     - Проверить существующую активность для указанного дня
     - Если активность существует и имеет тип `.workout`:
       - Отклонить изменение (вернуть ошибку на часы)
       - Или запросить подтверждение у пользователя (если изменение запрошено с iPhone)
     - Если активность не существует или имеет другой тип - выполнить изменение

4. **Уведомление пользователя:**
   - При попытке изменить активность на часах, если на iPhone есть незавершенная тренировка:
     - Показать сообщение об ошибке на часах: "Нельзя изменить активность: на телефоне начата тренировка"
     - Предложить завершить тренировку на телефоне или отменить её перед изменением активности

5. **Специальный случай - завершенные тренировки:**
   - Если тренировка завершена (есть `count` и `duration`), изменение на другой тип активности разрешено
   - Это позволяет пользователю изменить активность после завершения тренировки

**Реализация:**
- Логика проверки конфликтов реализуется в `WatchConnectivityManager` на iPhone при обработке команды `WATCH_COMMAND_SET_ACTIVITY`
- Используется `DailyActivitiesService` для проверки существующей активности
- При обнаружении конфликта возвращается ошибка на часы через WatchConnectivity
- Часы обрабатывают ошибку и показывают соответствующее сообщение пользователю

**Примечание:**
- Эта стратегия применяется только для конфликтов между часами и iPhone
- Конфликты при синхронизации с сервером разрешаются по существующей логике LWW в `DailyActivitiesService.downloadServerActivities()`

## Детальный план реализации

**Важно:** План следует принципам TDD (Test-Driven Development). Сначала пишутся тесты, затем реализация. UI реализуется в последнюю очередь.

### Принципы локализации для Watch App

1. **Использование общего файла локализации:**
   - Файл `SupportingFiles/Localizable.xcstrings` уже добавлен в Watch App target
   - Все строки для часов добавляются в этот же файл с префиксом `Watch.*`
   - Использование общего файла упрощает поддержку и позволяет переиспользовать общие строки

2. **Локализация displayName для часов:** ✅ Выполнено (см. раздел 1.2)

3. **Избежание дублей ключей:**
   - Перед добавлением новых ключей обязательно проверять существующие ключи в `Localizable.xcstrings`
   - Использовать существующие ключи там, где возможно:
     - `Home.Activity` для "Активность"
     - `.workoutDay`, `.stretchDay`, `.restDay`, `.sickDay` для типов активности (из `DayActivityType`)
     - Другие общие ключи из основного приложения
   - Добавлять новые ключи только если они специфичны для часов и не существуют в основном приложении

4. **Статус переводов:**
   - Все новые переводы должны иметь статус `"state" : "needs_review"`
   - Переводы добавляются на русский и английский языки

### Этап 1: Настройка проекта и инфраструктуры

#### 1.1 Настройка Watch App Target
- [x] Проверить настройки Watch App в Xcode проекте: ✅ Выполнено
  - ✅ Минимальная версия watchOS: 10.0 (совместимо с iOS 17.0+)
  - ✅ Bundle Identifier: `com.oleg991.SwiftUI-SotkaApp.watchkitapp`
  - ✅ WKCompanionAppBundleIdentifier настроен правильно
  - ✅ Entitlements подключены
  - ✅ WatchConnectivity доступен (встроен в watchOS 10.0+)
- [x] Настроить App Groups для обмена данными между iPhone и часами: ✅ Выполнено (см. детали в разделе 1.3)
  - ✅ App Group `group.com.sotka.app` добавлен в `SwiftUI-SotkaApp.entitlements`
  - ✅ App Group `group.com.sotka.app` добавлен в `SotkaWatch Watch App.entitlements`
- [x] Настроить WatchConnectivity capabilities: ✅ Выполнено
  - ✅ WatchConnectivity не требует специальных capabilities в entitlements - это встроенный фреймворк watchOS
  - ✅ Доступен в watchOS 10.0+ (используется в коде без дополнительных настроек)
- [x] Настроить минимальную версию watchOS (совместимо с iOS 17.0+): ✅ Выполнено
  - ✅ `WATCHOS_DEPLOYMENT_TARGET = 10.0` (watchOS 10.0 соответствует iOS 17.0+)
  - ✅ Настроено в Debug и Release конфигурациях
- [x] Добавить необходимые разрешения (если нужны): ✅ Выполнено
  - ✅ Для MVP функциональности (WatchConnectivity + App Groups) дополнительные разрешения не требуются
  - ✅ App Groups уже настроены в entitlements
  - ✅ WatchConnectivity работает без специальных разрешений
- [x] Настроить OSLog для логирования на часах (русский язык в логах): ✅ Выполнено
  - ✅ OSLog доступен на watchOS 10.0+ без дополнительных настроек
  - ✅ Использование: `Logger(subsystem: Bundle.main.bundleIdentifier ?? "SotkaWatch", category: String(describing: ClassName.self))`
  - ✅ Логирование на русском языке через строковые литералы (как в основном приложении)
  - ✅ Пример: `logger.info("Статус авторизации изменился: \(isAuthorized)")`
- [x] **Настроить Target Membership для общих моделей:** ✅ Выполнено
  - ✅ Добавлен `Models/Workout/WorkoutResult.swift` в Watch App target
  - ✅ Добавлен `Models/Workout/WorkoutPreviewTraining.swift` в Watch App target
  - ✅ Добавлен `Models/Workout/DayActivityType.swift` в Watch App target (уже был добавлен ранее)
  - ✅ Добавлен `Models/Workout/ExerciseExecutionType.swift` в Watch App target
  - ✅ Зависимости (SWUtils, SWNetwork и т.д.) не требуются для этих моделей - они используют только Foundation и SwiftUI
- [x] **Добавить `ExerciseType` в Watch App target:** ✅ Выполнено
  - ✅ Добавлен `Models/Workout/ExerciseType.swift` в Target Membership для Watch App (через PBXFileSystemSynchronizedBuildFileExceptionSet)
  - ✅ Необходим для отображения локализованных названий упражнений и иконок на экране тренировки
  - ✅ Использует ассеты из `ExercisesAssets.xcassets` (см. раздел 1.4)
- [x] Проверить зависимости моделей: ✅ Выполнено
  - ✅ Все модели используют только стандартные импорты: `Foundation`, `SwiftUI`
  - ✅ Все импорты доступны для Watch App (watchOS 10.0+)
  - ✅ Модели не используют SwiftData (@Model) - они простые структуры и enum'ы
  - ✅ Модели будут использоваться напрямую для передачи через WatchConnectivity (с Codable)
  - ✅ `WorkoutPreviewTraining` имеет инициализатор из SwiftData модели (`DayActivityTraining`), но сама модель не использует SwiftData
- [x] **Доработать AuthHelper для использования App Group:** ✅ Выполнено (см. детали в разделе 1.3)
  - ✅ `AuthHelperImp` использует App Group через `Constants.appGroupIdentifier` (`group.com.sotka.app`)
  - ✅ Используется `UserDefaults(suiteName: Constants.appGroupIdentifier)` вместо `UserDefaults.standard` с fallback на стандартный UserDefaults
  - ✅ Ключ `isAuthorized` (Key.isAuthorized.rawValue) сохраняется в App Group UserDefaults
  - ✅ Реализована автоматическая миграция данных из `UserDefaults.standard` в App Group при первом запуске
  - ✅ Тесты обновлены в `AuthHelperTests.swift` (проверка работы с App Group, fallback, миграция)

#### 1.2 Создание констант и утилит
- [x] Создать `WatchConstants.swift` - enum для команд WatchConnectivity (см. раздел "Команды WatchConnectivity" в технических деталях): ✅ Выполнено (добавлен enum `Constants.WatchCommand` в `SwiftUI-SotkaApp/Models/SWSharedModels/Constants.swift`, доступен обоим таргетам - основному приложению и Watch App)
- [x] Создать утилиты для работы с UserDefaults (App Group) для чтения статуса авторизации (см. детали в разделе 1.3): ✅ Выполнено (создан `Utilities/WatchAppGroupHelper.swift`)
- [x] **Настроить локализацию displayName для часов:** ✅ Выполнено (создан `InfoPlist.xcstrings`, настроен Target Membership и build settings)

#### 1.3 Настройка App Group для обмена данными между iPhone и часами

- [x] ✅ Выполнено: App Group `group.com.sotka.app` настроен в обоих targets, `AuthHelper` и `StatusManager` переведены на App Group с автоматической миграцией, добавлена константа `Constants.appGroupIdentifier`

**Создание утилит для работы с App Group на часах:**

- [x] ✅ Выполнено: Создан файл `WatchAppGroupHelper.swift` в папке `SotkaWatch Watch App/Utilities/` - структура с вычисляемыми свойствами:
  - ✅ `isAuthorized: Bool` - статус авторизации из App Group UserDefaults
  - ✅ `startDate: Date?` - дата начала программы из App Group UserDefaults
  - ✅ `currentDay: Int?` - текущий день программы, вычисленный из `startDate` через `DayCalculator`
  - ✅ Инициализатор с опциональным параметром `userDefaults` для тестирования
  - ✅ Логирование через OSLog на русском языке
  - ✅ Тесты созданы в `WatchAppGroupHelperTests.swift`

- [x] ✅ Принципы работы утилит реализованы:
  - ✅ Утилиты только читают данные из App Group UserDefaults
  - ✅ Не кэшируют данные отдельно - всегда читают напрямую из UserDefaults
  - ✅ Обрабатывают случаи, когда App Group недоступен (возвращают значения по умолчанию)
  - ✅ Используют безопасное извлечение опционалов (без force unwrap)
  - ✅ **Текущий день вычисляется локально** на часах из `startDate` с помощью `DayCalculator`, без запросов к iPhone

**Важные замечания:**

- **App Group идентификатор:** `group.com.sotka.app` (используется `Constants.appGroupIdentifier`)
- **Ключи:** `isAuthorized` (`Constants.isAuthorizedKey`), `startDate` (`Constants.startDateKey`), `restTime` (`Constants.restTimeKey`)
- **Синхронизация:** Статус авторизации, `startDate` и `restTime` читаются напрямую из App Group UserDefaults, синхронизация через WatchConnectivity не требуется
- **Текущий день:** Вычисляется локально на часах из `startDate` с помощью `DayCalculator`

**Доработка для времени отдыха (restTime):**

- [x] ✅ Выполнено: Добавлен ключ `restTimeKey` в `Constants`, обновлен `AppSettings` для сохранения в App Group с миграцией, добавлено чтение `restTime` в `WatchAppGroupHelper`, обновлен `WatchWorkoutService.getRestTime()` для использования App Group, созданы тесты

#### 1.4 Настройка ассетов упражнений для Watch App
- [x] **Создать `ExercisesAssets.xcassets` и настроить Target Membership:** ✅ Выполнено
  - ✅ Создан `SupportingFiles/ExercisesAssets.xcassets`, папка `Exercises` перемещена из основного `Assets.xcassets`
  - ✅ Добавлен в Target Membership для обоих таргетов (`SwiftUI-SotkaApp` и `SotkaWatch Watch App`)
  - ✅ Ассеты доступны в Watch App через `ExerciseType.image` без дублирования

### Этап 2: Добавление Codable к моделям и тесты

#### 2.1 Добавление Codable к простым структурам (TDD подход)
- [x] **Добавлен Codable к `WorkoutResult` и `WorkoutPreviewTraining`:** Обе структуры теперь поддерживают сериализацию/десериализацию JSON с безопасным извлечением опционалов. Созданы тесты для проверки корректности работы Codable.
- [x] **Создана структура `WorkoutData`:** Codable структура для передачи данных тренировки между iPhone и Apple Watch, размещена в `Models/SWSharedModels/WorkoutData.swift` с вычисляемым свойством `exerciseExecutionType` для безопасного преобразования.
- [x] **Добавлено вычисляемое свойство `workoutData` в `DayActivity`:** Преобразует SwiftData модель в Codable структуру для передачи на Apple Watch, возвращает `nil` для не-тренировочных активностей. Созданы тесты для проверки корректности преобразования.

#### 2.2 Настройка локализации для Watch App
- [ ] Следовать принципам локализации из раздела "Принципы локализации для Watch App" (см. выше)

### Этап 3: Сервисы и тесты для них

#### 3.1 WatchAuthService ✅
- [x] Реализован сервис с использованием `@Observable` (современный подход вместо `@Published`)
- [x] Все тесты написаны и проходят

#### 3.2 WatchConnectivityService ✅
- [x] Реализован сервис с `WCSessionDelegate` (через extension)
- [x] Реализован dependency injection через `WCSessionProtocol` для тестирования
- [x] Все тесты написаны (инициализация, обработка команд, ошибки, успешные сценарии, сериализация)

#### 3.3 WatchWorkoutService ✅
- [x] Реализован сервис
- [x] Все тесты написаны и проходят
- [x] Метод `getRestTime()` получает значение из App Group UserDefaults через `WatchAppGroupHelper` (см. раздел 1.3) ✅ Выполнено

### Этап 4: ViewModels и тесты для них

**Примечание:** ViewModels будут размещаться в папке `SotkaWatch Watch App/ViewModels/` при реализации.

#### 4.1 HomeViewModel (TDD подход)
- [x] ✅ Выполнено: Написаны тесты для `HomeViewModel` (инициализация, авторизация, загрузка данных, выбор активности, начало тренировки, обработка ошибок)
- [x] ✅ Выполнено: Реализован `HomeViewModel.swift` - @Observable класс с методами `loadData()`, `checkAuthStatusOnActivation()`, `selectActivity()`, `startWorkout()`, логирование через OSLog на русском языке, безопасное извлечение опционалов

#### 4.2 WorkoutViewModel (TDD подход)
- [x] ✅ Выполнено: Написаны тесты для `WorkoutViewModel` (инициализация, прогресс, завершение круга, таймер отдыха, завершение/прерывание тренировки, обработка ошибок)
- [x] ✅ Выполнено: Реализован `WorkoutViewModel.swift` - @Observable класс с методами `completeRound()`, `handleRestTimerFinish()`, `checkAndHandleExpiredRestTimer()`, `finishWorkout()`, `cancelWorkout()`, логирование через OSLog на русском языке, безопасное извлечение опционалов

### Этап 5: Интеграция с основным приложением (iPhone)

#### 5.1 WatchConnectivityManager на iPhone (TDD подход)
- [ ] **Написать тесты для `WatchConnectivityManager`:**
  - Тест инициализации WCSession
  - Тест обработки команды `WATCH_COMMAND_SET_ACTIVITY` (мок DailyActivitiesService)
  - Тест обработки команды `WATCH_COMMAND_SAVE_WORKOUT` (мок DailyActivitiesService)
  - Тест обработки команды `WATCH_COMMAND_GET_CURRENT_ACTIVITY` (мок DailyActivitiesService)
  - Тест обработки команды `WATCH_COMMAND_GET_WORKOUT_DATA` (мок WorkoutProgramCreator)
  - Тест отправки обновлений на часы (при изменении активности дня)
  - Тест отправки команды `PHONE_COMMAND_AUTH_STATUS_CHANGED` при успешной авторизации (мок AuthHelper)
  - Тест отправки команды `PHONE_COMMAND_AUTH_STATUS_CHANGED` при логауте (мок AuthHelper)
  - Тест обработки ошибок (неавторизованный пользователь, отсутствие данных)
  - **Примечание:** Команды проверки авторизации и получения текущего дня не нужны (см. раздел 1.3)
- [ ] **Реализовать `WatchConnectivityManager.swift` в основном приложении:**
  - Класс для связи с часами через WatchConnectivity
  - Реализация `WCSessionDelegate` для iPhone
  - Интеграция с `DailyActivitiesService` для сохранения активности и результата тренировки
  - Интеграция с `StatusManager` для работы с данными программы
  - Интеграция с `WorkoutProgramCreator` для получения данных тренировки
  - Интеграция с `AuthHelper` для отслеживания изменений статуса авторизации:
    - Подписка на изменения `AuthHelper.isAuthorized` (@Published) или использование callback/делегата
    - При успешной авторизации (`saveAuthData`) → отправка команды `PHONE_COMMAND_AUTH_STATUS_CHANGED` с `isAuthorized: true`
    - При логауте (`triggerLogout`) → отправка команды `PHONE_COMMAND_AUTH_STATUS_CHANGED` с `isAuthorized: false`
  - Обработка команд от часов:
    - `WATCH_COMMAND_SET_ACTIVITY` → сохранение через `DailyActivitiesService.set(_:for:context:)`
    - `WATCH_COMMAND_SAVE_WORKOUT` → сохранение через `DailyActivitiesService.createDailyActivity(_:context:)`
    - `WATCH_COMMAND_GET_CURRENT_ACTIVITY` → получение из SwiftData через `DailyActivitiesService`
    - `WATCH_COMMAND_GET_WORKOUT_DATA` → получение через `WorkoutProgramCreator`, преобразование в `WorkoutData`
  - Отправка обновлений на часы:
    - При изменении активности дня → отправка обновленной активности
    - При изменении статуса авторизации → отправка команды `PHONE_COMMAND_AUTH_STATUS_CHANGED`
  - Метод `sendAuthStatusChanged(_ isAuthorized: Bool)` - отправка команды `PHONE_COMMAND_AUTH_STATUS_CHANGED` на часы
  - **Примечание:** Статус авторизации и `startDate` читаются напрямую из App Group (см. раздел 1.3). Команда `PHONE_COMMAND_AUTH_STATUS_CHANGED` используется для оперативного уведомления часов об изменениях статуса авторизации
  - Сериализация/десериализация JSON через Codable
  - Логирование через OSLog на русском языке
  - Безопасное извлечение опционалов

### Этап 6: UI экранов (реализуется в последнюю очередь)

#### 6.1 Экран авторизации
- [x] Создать `AuthRequiredView.swift`: ✅ Выполнено (экран для неавторизованных пользователей, локализация добавлена)
- [ ] Использовать `AuthRequiredView` в нужных местах приложения:
  - Передавать в экран соответствующий статус авторизации
  - Интегрировать в навигационную структуру приложения

#### 6.2 Главный экран
- [x] Создать `HomeView.swift`: ✅ Частично выполнено (основной функционал реализован, локализация добавлена)
  - [ ] **Логика открытия экрана тренировки:**
    - При выборе активности `.workout` (из `DayActivitySelectionView` или изменении на `.workout` из `SelectedActivityView`) автоматически открывать `WorkoutView`
    - Интегрировать открытие `WorkoutView` в обработку `onSelect` callback в `DayActivityView`

#### 6.3 Экран выбора активности
- [x] **Создать экран выбора активности:** ✅ Выполнено (`DayActivitySelectionView.swift` с 4 вариантами активности)
- [x] **Базовый UI для выбора и изменения активности:** ✅ Выполнено (`DayActivityView`, `SelectedActivityView`, `DayActivitySelectionView`)
- [ ] **Доработать `SelectedActivityView` для отображения данных тренировки (TODO в коде):**
  - **Важно:** Это экран результата тренировки - после завершения тренировки пользователь возвращается сюда и видит результат выполненной тренировки
  - Для кейса `.workout` отобразить данные тренировки аналогично `DayActivityContentView` + `DayActivityCommentView` (как в основном приложении)
  - Отобразить информацию о выполненной тренировке:
    - Тип выполнения (`ExerciseExecutionType`) с количеством кругов/подходов
    - Список упражнений (`DayActivityTraining`) с количеством повторений для каждого
    - Комментарий пользователя (если есть)
  - Получить данные тренировки для текущего дня через `WatchConnectivityService.requestWorkoutData(day:)` или из сохраненной активности (`DayActivity`)
  - Адаптировать отображение для маленького экрана часов (упрощенный формат)
  - После завершения тренировки в `WorkoutView` пользователь возвращается в `SelectedActivityView` и видит результат выполненной тренировки
- [ ] **Реализовать логику выбора/изменения активности:**
  - В `HomeView` передать реальную выбранную активность для текущего дня (убрать TODO)
  - Реализовать обработку выбора активности через `onSelect` callback в `DayActivityView`:
    - Вызов `HomeViewModel.selectActivity(_:)` для отправки на iPhone через `WatchConnectivityService`
    - Показ индикатора отправки активности на iPhone
    - Обработка ошибок связи
    - **Важно:** Если выбранная активность = `.workout`, открыть экран выполнения тренировки (`WorkoutView`) после успешного сохранения
    - Если выбранная активность != `.workout`, остаться на текущем экране (обновить отображение)
  - Локализованные строки для индикаторов и ошибок в `Localizable.xcstrings` (общий файл):
    - `Watch.Activity.Saving` - "Сохранение..." (новый ключ, специфичен для часов)
    - `Watch.Activity.Error` - "Ошибка сохранения" (новый ключ, специфичен для часов)
  - Добавить переводы на русский и английский языки
  - Установить статус новых переводов: `"state" : "needs_review"`

#### 6.4 Экран выполнения тренировки
- [ ] **Создать `WorkoutView.swift`:**
  - **Важно:** Экран открывается автоматически при выборе активности `.workout` (из `SelectedActivityView` или `DayActivitySelectionView`)
  - Экран выполнения тренировки
  - Упрощенный интерфейс для часов:
    - Отображение текущего упражнения (название через `ExerciseType.localizedTitle` или `ExerciseType.makeLocalizedTitle`, иконка через `ExerciseType.image` из `ExercisesAssets.xcassets`)
    - Отображение текущего круга/подхода
    - Кнопка "Завершить круг/подход"
    - Кнопка "Завершить тренировку"
    - Кнопка "Прервать тренировку"
    - Отображение времени тренировки
  - **Таймер отдыха между кругами/подходами:**
    - Создать `WorkoutRestTimerView.swift` - упрощенная версия таймера отдыха для часов (аналогично `WorkoutTimerScreen` из основного приложения)
    - Показывать таймер отдыха после завершения круга/подхода (если есть время отдыха)
    - Отображать оставшееся время отдыха в формате MM:SS
    - Круговой прогресс-бар (адаптированный для маленького экрана часов)
    - Кнопка "Завершить" для досрочного завершения отдыха
    - Автоматическое завершение при достижении 0 секунд
    - Обработка фонового режима (сворачивание/разворачивание приложения) - вычисление правильного оставшегося времени на основе реального прошедшего времени
    - Отслеживание `scenePhase` для обработки сворачивания/разворачивания
    - Показывать через `fullScreenCover` или модальный экран поверх `WorkoutView`
    - Интеграция с `WorkoutViewModel.handleRestTimerFinish(force:)` для обработки завершения
  - Индикатор сохранения результата
  - Обработка ошибок
  - Локализованные строки в `Localizable.xcstrings` (общий файл):
    - Проверить наличие ключей для "Упражнение", "Круг" - если есть, использовать их, иначе добавить новые
    - `Watch.Workout.Exercise` - "Упражнение" (новый ключ, если не существует в основном приложении)
    - `Watch.Workout.Round` - "Круг" (новый ключ, если не существует в основном приложении)
    - `Watch.Workout.CompleteRound` - "Завершить круг" (новый ключ, специфичен для часов)
    - Проверить наличие ключа для "Завершить тренировку" - если есть, использовать его, иначе добавить `Watch.Workout.Finish`
    - Проверить наличие ключа для "Прервать тренировку" - если есть, использовать его, иначе добавить `Watch.Workout.Cancel`
    - `Watch.Workout.Saving` - "Сохранение..." (новый ключ, специфичен для часов)
    - `Watch.Workout.Error` - "Ошибка сохранения" (новый ключ, специфичен для часов)
    - Для таймера отдыха:
      - Использовать существующий ключ `TimerScreen.Title` для "Отдых" (если есть в основном приложении)
      - Использовать существующий ключ `TimerScreen.FinishButton` для "Завершить" (если есть в основном приложении)
      - Если ключи не существуют, добавить `Watch.Timer.Title` и `Watch.Timer.FinishButton`
  - Добавить переводы на русский и английский языки
  - Установить статус новых переводов: `"state" : "needs_review"`
  - Минималистичный дизайн для часов

#### 6.5 Навигация и главный файл приложения
- [ ] Обновить `SotkaWatchApp.swift`:
  - Настройка навигации между экранами
  - Проверка авторизации при запуске
  - Переход на `AuthRequiredView` если не авторизован
  - Переход на `HomeView` если авторизован
  - Настройка NavigationStack для навигации между экранами
  - **Проверка статуса авторизации при активации приложения:**
    - Использовать модификатор `.task(id: scenePhase)` для отслеживания изменений `scenePhase`
    - При переходе `scenePhase` в `.active` вызывать `HomeViewModel.checkAuthStatusOnActivation()` для проверки актуального статуса авторизации из App Group UserDefaults
    - Это обеспечивает получение актуального статуса авторизации даже если команда `PHONE_COMMAND_AUTH_STATUS_CHANGED` не была доставлена (например, при отсутствии связи)
- [ ] Настроить навигацию:
  - Простая навигация между экранами
  - Кнопка "Назад" на каждом экране (где нужно)
  - Минимальное количество экранов
  - Быстрый доступ к основным функциям

### Этап 7: UI/UX оптимизация для часов

#### 7.1 Адаптация дизайна
- [ ] Минималистичный дизайн для маленького экрана
- [ ] Крупные кнопки для удобного нажатия
- [ ] Оптимизация шрифтов для читаемости
- [ ] Использование системных цветов и иконок
- [ ] Поддержка темной темы

#### 7.2 Обратная связь
- [ ] Haptic feedback при действиях
- [ ] Визуальная обратная связь (анимации)
- [ ] Индикаторы загрузки и синхронизации
- [ ] Сообщения об ошибках

### Этап 8: Финальное тестирование и документация

#### 8.1 Интеграционные тесты
- [ ] Тесты синхронизации между часами и iPhone (моки)
- [ ] Тесты обработки команд WatchConnectivity
- [ ] Тесты офлайн-работы (отсутствие связи с iPhone)

#### 8.2 UI-тесты (опционально)
- [ ] Тесты основных сценариев использования
- [ ] Тесты навигации между экранами
- [ ] Тесты выбора активности
- [ ] Тесты выполнения тренировки

#### 8.3 Тестирование на устройствах
- [ ] Тестирование на реальных часах (разные модели)
- [ ] Тестирование синхронизации между часами и iPhone
- [ ] Тестирование офлайн-работы
- [ ] Тестирование производительности

#### 8.4 Документация
- [ ] Обновление `feature-map.md` с информацией о часах
- [ ] Создание документации по архитектуре часов (если нужно)
- [ ] Документация API WatchConnectivity
- [ ] Инструкции по тестированию

#### 8.5 Оптимизация
- [ ] Оптимизация размера приложения
- [ ] Оптимизация производительности
- [ ] Оптимизация энергопотребления
- [ ] Оптимизация синхронизации

#### 8.6 Финальная проверка
- [ ] Проверка всех функций
- [ ] Проверка синхронизации
- [ ] Проверка офлайн-работы
- [ ] Проверка на разных моделях часов
- [ ] Проверка локализации (русский и английский)
- [ ] Проверка логирования (русский язык)
- [ ] Проверка безопасного извлечения опционалов (нет force unwrap)

## Технические детали

### Модели данных

#### Модели с Codable для передачи данных

**WorkoutResult** (обновлена для поддержки Codable):
```swift
// Models/Workout/WorkoutResult.swift
struct WorkoutResult: Equatable, Codable {
    let count: Int
    let duration: Int?
}
```

**WorkoutPreviewTraining** (обновлена для поддержки Codable):
```swift
// Models/Workout/WorkoutPreviewTraining.swift
struct WorkoutPreviewTraining: Equatable, Identifiable, Codable {
    let id: String
    let count: Int?
    let typeId: Int?
    let customTypeId: String?
    let sortOrder: Int?
    // ... остальные методы и свойства
}
```

**WorkoutData** (новая структура для передачи полных данных тренировки):
```swift
// Models/Workout/WorkoutData.swift
struct WorkoutData: Codable {
    let day: Int
    let executionType: Int  // ExerciseExecutionType.rawValue
    let trainings: [WorkoutPreviewTraining]
    let plannedCount: Int?
    
    // Вычисляемое свойство для преобразования executionType в enum
    var exerciseExecutionType: ExerciseExecutionType? {
        ExerciseExecutionType(rawValue: executionType)
    }
}
```

**Примечание:**
- Простые структуры (`WorkoutResult`, `WorkoutPreviewTraining`) получают Codable для прямой передачи через WatchConnectivity
- Enum'ы (`DayActivityType`, `ExerciseExecutionType`) передаются через rawValue (Int)
- `WorkoutData` - новая структура для передачи полных данных тренировки, размещается в общих моделях
- `ExerciseType` добавлен в Watch App target для использования локализованных названий упражнений и иконок на экране тренировки
- Ассеты упражнений находятся в отдельном `ExercisesAssets.xcassets`, доступном обоим таргетам, что позволяет использовать иконки упражнений без дублирования
- Модели с `@Model` (SwiftData) не используются напрямую на часах, только для преобразования в простые структуры

### Команды WatchConnectivity

```swift
extension Constants {
    /// Команды для обмена данными между часами и iPhone через WatchConnectivity
    enum WatchCommand: String {
        // От часов к iPhone
        case setActivity = "WATCH_COMMAND_SET_ACTIVITY"
        case saveWorkout = "WATCH_COMMAND_SAVE_WORKOUT"
        case getCurrentActivity = "WATCH_COMMAND_GET_CURRENT_ACTIVITY"
        case getWorkoutData = "WATCH_COMMAND_GET_WORKOUT_DATA"
        
        // От iPhone к часам
        case currentActivity = "PHONE_COMMAND_CURRENT_ACTIVITY"
        case sendWorkoutData = "PHONE_COMMAND_SEND_WORKOUT_DATA"
        case authStatusChanged = "PHONE_COMMAND_AUTH_STATUS_CHANGED"
    }
}
```

**Примечание:** Enum `Constants.WatchCommand` находится в файле `SwiftUI-SotkaApp/Models/SWSharedModels/Constants.swift` и доступен обоим таргетам (основному приложению и Watch App).

### Формат сообщений WatchConnectivity

**Установка активности:**
```json
{
    "command": "WATCH_COMMAND_SET_ACTIVITY",
    "day": 42,
    "activityType": 0
}
```

**Сохранение тренировки:**
```json
{
    "command": "WATCH_COMMAND_SAVE_WORKOUT",
    "day": 42,
    "result": {
        "count": 4,
        "duration": 1800
    },
    "executionType": 0,
    "trainingType": 1
}
```
*Примечание: `result` содержит сериализованный `WorkoutResult` (Codable) в JSON формате*

**Примечание:** Команды проверки авторизации и получения/обновления текущего дня не нужны (см. раздел 1.3). Команды для получения данных пользователя также не нужны - часы не отображают данные пользователя (имя, email и т.д.).

**Ответ с текущей активностью дня:**
```json
{
    "command": "PHONE_COMMAND_CURRENT_ACTIVITY",
    "day": 42,
    "activityType": 0,
    "count": null,
    "duration": null
}
```

**Уведомление об изменении статуса авторизации:**
```json
{
    "command": "PHONE_COMMAND_AUTH_STATUS_CHANGED",
    "isAuthorized": true
}
```
*Примечание: Команда отправляется при успешной авторизации (`isAuthorized: true`) или при логауте (`isAuthorized: false`). Часы также проверяют статус авторизации при активации приложения через `task(id: scenePhase)` для обеспечения актуальности данных даже при отсутствии связи.*

## Риски и митигация

### Риск 1: Ограничения WatchConnectivity
- **Проблема:** WatchConnectivity может быть недоступен или нестабилен
- **Митигация:** Реализовать очередь несинхронизированных действий, повторные попытки синхронизации

### Риск 2: Различия в данных между часами и iPhone
- **Проблема:** Данные на часах могут отличаться от данных на iPhone
- **Митигация:** iPhone является основным источником истины, часы получают обновления от iPhone

### Риск 3: Производительность на часах
- **Проблема:** Ограниченные ресурсы часов могут влиять на производительность
- **Митигация:** Оптимизация кода, минимальное использование ресурсов, кэширование данных

### Риск 4: Сложность синхронизации
- **Проблема:** Синхронизация между часами и iPhone может быть сложной
- **Митигация:** Простая архитектура синхронизации, четкие команды, обработка ошибок

### Риск 5: Работа часов без авторизации
- **Проблема:** Часы могут попытаться работать без авторизации на iPhone
- **Митигация:** Обязательная проверка авторизации при запуске, блокировка функционала без авторизации, экран с сообщением о необходимости авторизации

### Риск 6: Отсутствие связи с iPhone
- **Проблема:** Часы могут быть недоступны для связи с iPhone
- **Митигация:** Показ сообщения об ошибке, блокировка действий, требующих сохранения данных. Минимальное кэширование только для отображения текущего дня (опционально)

## Приоритеты разработки

### Высокий приоритет (MVP)
1. **Добавление Codable к простым моделям** для передачи данных
2. **Проверка авторизации и блокировка функционала без авторизации**
3. **Запрос данных с iPhone** (текущий день, активность, данные тренировки)
4. **Отправка действий в iPhone** для сохранения в SwiftData (с использованием Codable моделей)
5. Главный экран с отображением текущего дня (только для авторизованных)
6. Выбор типа активности (сохранение через iPhone)
7. Обработка отсутствия связи с iPhone

### Средний приоритет
1. Выполнение тренировки
2. Сохранение результата тренировки
3. Полная синхронизация данных

### Низкий приоритет (будущие улучшения)
1. Расширенная статистика тренировок
2. Интеграция с HealthKit
3. Уведомления о тренировках
4. Циферблаты с данными программы

## Отличия от реализации в старом приложении (SOTKA-OBJc)

Этот раздел описывает ключевые отличия планируемой реализации в новом приложении от реализации в старом приложении SOTKA-OBJc.

### Архитектура хранения данных

**Старое приложение (SOTKA-OBJc):**
- Часы используют **CoreData** для локального хранения данных
- Модели: `WatchDbDay`, `WatchDbTraining`, `WatchDbCustomExercise`, `WatchDbSettings`
- Данные сохраняются локально на часах с флагом `synched` для отслеживания синхронизации
- Двусторонняя синхронизация: часы работают независимо, синхронизируются периодически
- Очередь несинхронизированных данных на часах

**Новое приложение:**
- Часы **не хранят данные локально** (статус авторизации читается напрямую из UserDefaults App Group, без отдельного кэширования)
- Все данные запрашиваются с iPhone в реальном времени
- iPhone является **единственным хранилищем данных** (SwiftData)
- Часы работают как **клиент iPhone приложения**
- Нет очереди синхронизации - все действия передаются немедленно

### Формат передачи данных

**Старое приложение:**
- Используются **JSON строки** (NSString) в Dictionary
- Команды передаются как **числовые константы** (enum WATCH_COMMANDS: 0, 1, 2...)
- Данные сериализуются в JSON строку через `toJSONString()`
- Пример: `@{@"command": @"0", @"days": jsonString}`

**Новое приложение:**
- Используются **модели с Codable** для прямой передачи данных (без DTO)
- Команды передаются как **строковые enum** (WatchCommand: "WATCH_COMMAND_GET_TRAIN_LIST")
- Данные сериализуются через JSONEncoder/JSONDecoder
- Пример: `{"command": "WATCH_COMMAND_SAVE_WORKOUT", "result": {...}}`

### Команды WatchConnectivity

**Старое приложение:**
- `WATCH_COMMAND_GET_TRAIN_LIST` (0) - запрос данных тренировки
- `WATCH_COMMAND_SAVE_TRAININGS` (1) - сохранение тренировок (массив дней)
- `PHONE_COMMAND_UPDATE_CURRENT_DAY` (2) - обновление текущего дня
- `PHONE_SYNC_REQUEST` (3) - запрос синхронизации
- `PHONE_COMMAND_GET_UNSYNCED_TRAININGS` (4) - запрос несинхронизированных тренировок

**Новое приложение:**
- Расширенный набор команд с явными названиями
- Более детальное разделение команд (отдельно для активности и тренировки)
- **Примечание:** Команды проверки авторизации и выхода из аккаунта не нужны, так как статус авторизации читается напрямую из App Group UserDefaults (см. раздел 1.3). Команды для получения данных пользователя также не нужны - часы не отображают данные пользователя.

### Авторизация

**Старое приложение:**
- Не видно явной проверки авторизации при запуске часов
- Часы могут работать без явной проверки статуса авторизации

**Новое приложение:**
- **Обязательная проверка авторизации** при запуске приложения на часах
- Блокировка функционала без авторизации
- Экран `AuthRequiredView` для неавторизованных пользователей
- Статус авторизации читается напрямую из App Group UserDefaults (см. раздел 1.3)

### Обработка данных тренировки

**Старое приложение:**
- Данные тренировки передаются как `WatchObject` (JSON строка)
- Сохранение тренировок происходит пакетами (массив дней)
- Локальное сохранение на часах перед синхронизацией

**Новое приложение:**
- Данные тренировки передаются через модели с Codable (`WorkoutData`, `WorkoutResult`)
- Сохранение происходит по одной активности/тренировке
- Немедленная передача в iPhone без локального сохранения

### Синхронизация

**Старое приложение:**
- Двусторонняя синхронизация с флагом `synched`
- Часы могут работать офлайн с последующей синхронизацией
- Очередь несинхронизированных данных на часах
- iPhone может запрашивать несинхронизированные данные с часов

**Новое приложение:**
- Односторонняя передача данных: часы → iPhone (для сохранения)
- Часы запрашивают данные с iPhone в реальном времени
- Нет очереди синхронизации - все действия передаются немедленно
- При отсутствии связи показывается ошибка, действия не выполняются

### Технологии

**Старое приложение:**
- Objective-C
- CoreData на часах
- UIKit для часов (WatchKit)
- JSON строки для передачи данных

**Новое приложение:**
- Swift 6.0
- SwiftData на iPhone (не используется на часах)
- SwiftUI для часов
- Codable модели для прямой передачи данных (без DTO)

### Преимущества нового подхода

1. **Упрощенная архитектура:**
   - Нет дублирования данных между часами и iPhone
   - Нет конфликтов данных
   - Проще поддержка и отладка

2. **Актуальность данных:**
   - Данные всегда актуальны (запрашиваются в реальном времени)
   - Нет рассинхронизации между устройствами

3. **Безопасность:**
   - Обязательная проверка авторизации
   - Данные хранятся только на iPhone

4. **Современные технологии:**
   - SwiftUI вместо WatchKit
   - SwiftData вместо CoreData
   - Codable модели вместо ручной сериализации JSON и DTO

### Недостатки нового подхода

1. **Зависимость от связи:**
   - Часы не могут работать полностью офлайн
   - Требуется постоянная связь с iPhone для работы

2. **Производительность:**
   - Каждый запрос требует связи с iPhone
   - Может быть медленнее при плохой связи

3. **Ограничения:**
   - Меньше автономности часов
   - Зависимость от доступности iPhone

## Заключение

Этот план описывает детальную разработку приложения для Apple Watch с сокращенным функционалом по сравнению с основным iOS-приложением. Основные компоненты:

1. **Авторизация** - проверка статуса авторизации и блокировка функционала без авторизации
2. **Локальное вычисление текущего дня** - вычисляется локально на часах из `startDate` с помощью `DayCalculator` (см. раздел 1.3)
3. **Запрос данных с iPhone** - данные активности и тренировок запрашиваются с iPhone в реальном времени
4. **Сохранение через iPhone** - все действия передаются в iPhone для сохранения в SwiftData
5. **Главный экран** - отображение текущего дня и активности (только для авторизованных)
6. **Выбор активности** - выбор типа активности из 4 вариантов (сохранение через iPhone)
7. **Выполнение тренировки** - упрощенный интерфейс для выполнения тренировки (данные с iPhone, сохранение через iPhone)

### Ключевые принципы

- **iPhone приложение - единственное хранилище данных**: все данные хранятся только на iPhone в SwiftData, часы не хранят данные локально
- **Часы как клиент**: часы запрашивают данные с iPhone и отправляют действия для сохранения, не хранят данные самостоятельно
- **Обязательная авторизация**: приложение для часов работает только после успешной авторизации в iPhone приложении
- **Чтение статуса авторизации и `startDate`**: напрямую из App Group UserDefaults (см. раздел 1.3)
- **Текущий день**: вычисляется локально на часах из `startDate` с помощью `DayCalculator`
- **Безопасность**: при выходе из аккаунта статус обновляется в App Group UserDefaults
- **Обработка офлайн-режима**: при отсутствии связи с iPhone показывать сообщение об ошибке, не выполнять действия, требующие сохранения

Приложение для часов работает как клиент iPhone приложения, запрашивая данные и отправляя действия для сохранения. Все данные хранятся только на iPhone в SwiftData, что упрощает архитектуру и исключает конфликты данных.

