# План разработки приложения для Apple Watch

## Обзор

Этот документ описывает детальный план разработки приложения для Apple Watch с сокращенным функционалом по сравнению с основным iOS-приложением. Приложение для часов будет поддерживать выбор типа активности на день и выполнение тренировок с синхронизацией данных между часами и iPhone.

## Цели и ограничения

### Функционал для часов
- Выбор типа активности на сегодняшний день из 4 вариантов (`DayActivityType`):
  - `workout` - тренировка
  - `stretch` - растяжка
  - `rest` - отдых
  - `sick` - болезнь
- Выполнение тренировки (если выбран тип `workout`):
  - Упрощенный интерфейс выполнения тренировки
  - Сохранение результата тренировки
- Синхронизация данных между часами и iPhone:
  - Двусторонняя синхронизация через WatchConnectivity
  - Синхронизация выбранных активностей
  - Синхронизация результатов тренировок
  - Синхронизация текущего дня программы

### Ограничения
- Минимальный UI для часов (ограниченный размер экрана)
- Упрощенная логика тренировок (без сложных настроек)
- **Часы не хранят данные локально** - все данные запрашиваются с iPhone и сохраняются через iPhone в SwiftData
- **Статус авторизации и номер текущего дня** передаются через WatchConnectivity (см. раздел 1.3)
- **Текущий день** получается только из WatchConnectivity (готовый номер дня), при отсутствии связи показывается `AuthRequiredView`
- **iPhone приложение является единственным хранилищем данных** (SwiftData)
- **Приложение для часов работает только после успешной авторизации в iPhone приложении**

## Архитектура

### Структура проекта

```
SotkaWatch Watch App/
├── Models/
│   └── AuthState.swift                 # Модель состояния авторизации для Watch App ✅
├── Services/
│   ├── WatchAuthService.swift          # Сервис авторизации для Watch App ✅
│   ├── WatchAuthServiceProtocol.swift  # Протокол сервиса авторизации ✅
│   ├── WatchConnectivityService.swift  # Сервис связи с iPhone через WatchConnectivity ✅
│   ├── WatchConnectivityServiceProtocol.swift # Протокол сервиса связи ✅
│   ├── WatchWorkoutService.swift       # Сервис тренировок для Watch App ✅
│   └── WCSessionProtocol.swift         # Протокол для WCSession (для тестирования) ✅
├── ViewModels/
│   ├── HomeViewModel.swift              # ViewModel для главного экрана ✅
│   ├── WorkoutViewModel.swift          # ViewModel для экрана тренировки ✅
│   └── WorkoutPreviewViewModel.swift   # ViewModel для экрана превью тренировки ✅
├── Views/
│   ├── AuthRequiredView.swift          # Экран для неавторизованных пользователей ✅
│   ├── HomeView.swift                  # Главный экран часов ✅
│   ├── DayActivityView.swift           # Экран активности дня (выбор/отображение) ✅
│   ├── DayActivitySelectionView.swift  # Выбор типа активности ✅
│   ├── SelectedActivityView.swift      # Отображение выбранной активности ✅
│   ├── WatchDayActivityTrainingView.swift # Компонент отображения данных тренировки ✅
│   ├── WatchDayActivityCommentView.swift  # Компонент отображения комментария ✅
│   ├── WorkoutPreviewView.swift        # Экран превью тренировки ✅
│   ├── WorkoutEditView.swift           # Экран редактирования упражнений в тренировке ✅
│   ├── WorkoutStepperView.swift        # Компонент для изменения значений (stepper) ✅
│   ├── WorkoutView.swift               # Экран выполнения тренировки ✅
│   └── WorkoutRestTimerView.swift      # Таймер отдыха между кругами/подходами ✅

Примечание: 
- Модели данных переиспользуются из основного приложения, локальные модели для Watch App размещаются в `Models/`
- Модели для этапов тренировки (WorkoutStep, WorkoutState, WorkoutStepState) добавлены в Watch App target
- Простые структуры получают Codable для передачи через WatchConnectivity, модели с `@Model` (SwiftData) не используются на часах
- Ассеты упражнений в отдельном `ExercisesAssets.xcassets`, доступном обоим таргетам
```

### Технологии

- **SwiftUI** - для UI (watchOS поддерживает SwiftUI)
- **WatchConnectivity** - для связи с iPhone
- **OSLog** - для логирования

**Важно:** 
- Часы не используют SwiftData, все данные запрашиваются с iPhone в реальном времени
- Модели переиспользуются из основного приложения, простые структуры получают Codable для передачи через WatchConnectivity

### Обмен данными между часами и iPhone

#### WatchConnectivity Service

**Архитектура связи:**
- iPhone - единственное хранилище данных (SwiftData)
- Часы не хранят данные локально - все данные получаются только через WatchConnectivity в реальном времени
- Все действия с часов передаются в iPhone через WatchConnectivity (`sendMessage`)
- Статус авторизации и номер текущего дня передаются через WatchConnectivity, при отсутствии связи показывается `AuthRequiredView`

**Команды синхронизации:** (см. раздел "Команды WatchConnectivity" ниже)

**Механизмы передачи данных:**
- `sendMessage` - для немедленной передачи данных, требует активного соединения

**Формат данных:**
- JSON для передачи сложных структур
- Простые типы (Int, String, Bool) для простых команд

#### Разрешение конфликтов при одновременном изменении активности

**Проблема:**
При одновременном изменении активности на один и тот же день с разных устройств (часы и iPhone) могут возникать конфликты. Например:
- На iPhone начали тренировку (создана активность `.workout`), но не закончили и свернули приложение
- На часах выбрали активность "отдых" для того же дня
- Без специальной обработки активность будет перезаписана на "отдых", что приведет к потере данных о тренировке

**Стратегия разрешения конфликтов:**

1. **Приоритет незавершенных тренировок:**
   - Если на день уже существует активность типа `.workout` (тренировка), изменение на другой тип активности (`.rest`, `.stretch`, `.sick`) должно быть запрещено или требовать подтверждения
   - Это предотвращает случайную потерю данных о начатой тренировке
   - Проверка выполняется на iPhone при обработке команды `WATCH_COMMAND_SET_ACTIVITY` от часов

2. **Last Write Wins (LWW) для других случаев:**
   - Для активностей типа `.rest`, `.stretch`, `.sick` применяется стратегия LWW на основе `modifyDate`
   - Последнее изменение побеждает (обновляется `modifyDate` при каждом изменении)
   - Это соответствует существующей логике разрешения конфликтов при синхронизации с сервером

3. **Проверка перед изменением:**
   - При получении команды `WATCH_COMMAND_SET_ACTIVITY` на iPhone:
     - Проверить существующую активность для указанного дня
     - Если активность существует и имеет тип `.workout`:
       - Отклонить изменение (вернуть ошибку на часы)
       - Или запросить подтверждение у пользователя (если изменение запрошено с iPhone)
     - Если активность не существует или имеет другой тип - выполнить изменение

4. **Уведомление пользователя:**
   - При попытке изменить активность на часах, если на iPhone есть незавершенная тренировка:
     - Показать сообщение об ошибке на часах: "Нельзя изменить активность: на телефоне начата тренировка"
     - Предложить завершить тренировку на телефоне или отменить её перед изменением активности

5. **Специальный случай - завершенные тренировки:**
   - Если тренировка завершена (есть `count` и `duration`), изменение на другой тип активности разрешено
   - Это позволяет пользователю изменить активность после завершения тренировки

**Реализация:**
- Логика проверки конфликтов реализуется в `WatchConnectivityManager` на iPhone при обработке команды `WATCH_COMMAND_SET_ACTIVITY`
- Используется `DailyActivitiesService` для проверки существующей активности
- При обнаружении конфликта возвращается ошибка на часы через WatchConnectivity
- Часы обрабатывают ошибку и показывают соответствующее сообщение пользователю

**Примечание:**
- Эта стратегия применяется только для конфликтов между часами и iPhone
- Конфликты при синхронизации с сервером разрешаются по существующей логике LWW в `DailyActivitiesService.downloadServerActivities()`

## Детальный план реализации

**Важно:** План следует принципам TDD (Test-Driven Development). Сначала пишутся тесты, затем реализация. UI реализуется в последнюю очередь.

### Принципы локализации для Watch App

1. **Использование общего файла локализации:**
   - Файл `SupportingFiles/Localizable.xcstrings` уже добавлен в Watch App target
   - Все строки для часов добавляются в этот же файл с префиксом `Watch.*`
   - Использование общего файла упрощает поддержку и позволяет переиспользовать общие строки

2. **Локализация displayName для часов:** ✅ Выполнено (см. раздел 1.2)

3. **Избежание дублей ключей:**
   - Перед добавлением новых ключей обязательно проверять существующие ключи в `Localizable.xcstrings`
   - Использовать существующие ключи там, где возможно (`Home.Activity`, `.workoutDay`, `.stretchDay`, `.restDay`, `.sickDay` и др.)
   - Добавлять новые ключи только если они специфичны для часов и не существуют в основном приложении

4. **Статус переводов:**
   - Все новые переводы должны иметь статус `"state" : "needs_review"`
   - Переводы добавляются на русский и английский языки

### Этап 1: Настройка проекта и инфраструктуры ✅ Выполнено

#### 1.1 Настройка Watch App Target ✅ Выполнено
- [x] ✅ watchOS 10.0, WatchConnectivity, OSLog настроены
- [x] ✅ Модели добавлены в Watch App target
- [x] ✅ `AuthHelper` использует обычный UserDefaults

#### 1.2 Константы и утилиты ✅ Выполнено
- [x] ✅ `Constants.WatchCommand`, локализация displayName

#### 1.3 Настройка хранения данных ✅ Выполнено
- [x] ✅ `AuthHelper`, `StatusManager`, `AppSettings` используют обычный UserDefaults
- [x] ✅ Все данные на часах получаются только через WatchConnectivity, при отсутствии связи показывается `AuthRequiredView`

#### 1.4 Ассеты упражнений ✅ Выполнено
- [x] ✅ `ExercisesAssets.xcassets` создан и добавлен в оба таргета

### Этап 2: Добавление Codable к моделям ✅ Выполнено
- [x] ✅ Codable добавлен к моделям, создана структура `WorkoutData`

### Этап 3: Сервисы ✅ Выполнено
- [x] ✅ `WatchAuthService`, `WatchConnectivityService`, `WatchWorkoutService` реализованы

### Этап 4: ViewModels ✅ Выполнено
- [x] ✅ `HomeViewModel`, `WorkoutViewModel`, `WorkoutPreviewViewModel` реализованы

### Этап 5: Интеграция с iPhone ✅ Выполнено
- [x] ✅ `WatchConnectivityManager` реализован с обработкой команд, очередью запросов и проверкой конфликтов
- [x] ✅ Методы для работы с активностями и отправки данных на часы добавлены в `DailyActivitiesService` и `StatusManager`
- [x] ✅ Синхронизация через `sendMessage` (отключен `updateApplicationContext` из-за проблем с рекурсией в тестах)

**Важные примечания:**
- ⚠️ WCSessionDelegate для watchOS: НЕ добавлять методы `sessionDidBecomeInactive` и `sessionDidDeactivate` (unavailable на watchOS)
- Actor isolation: Методы делегата `nonisolated` добавляют запросы в очередь через `Task { @MainActor in }`, обработка через `processPendingRequests(context:)` во вьюхе
- Авторизация и текущий день: ✅ Реализовано через WatchConnectivity (`sendMessage`). Команды отправляются при изменении статуса и `currentDayCalculator`. На часах данные получаются только из WatchConnectivity, при отсутствии связи показывается `AuthRequiredView`

### Этап 6: UI экранов ✅ Выполнено

#### 6.1 Экран авторизации ✅ Выполнено
- [x] ✅ `AuthRequiredView` создан и интегрирован

#### 6.2 Главный экран ✅ Выполнено
- [x] ✅ `HomeView` создан с отображением активности, выбором активности, открытием превью тренировки
- [x] ✅ Авторизация и синхронизация данных через WatchConnectivity (`sendMessage`). Данные получаются только из `WatchConnectivityService`, при ошибке или отсутствии связи показывается `AuthRequiredView`

#### 6.3 Экран выбора активности ✅ Выполнено
- [x] ✅ Созданы экраны: `DayActivitySelectionView`, `DayActivityView`, `SelectedActivityView` с полным функционалом
- [ ] **TODO:** Добавить локализованные строки для индикаторов и ошибок (`Watch.Activity.Saving`, `Watch.Activity.Error`) в `Localizable.xcstrings`

#### 6.3.1 Экран превью тренировки ✅ Выполнено
- [x] ✅ `WorkoutPreviewView` и `WorkoutEditView` созданы с полным функционалом редактирования упражнений и комментариев

#### 6.4 Экран выполнения тренировки ✅ Выполнено
- [x] ✅ `WorkoutView` и `WorkoutRestTimerView` созданы с полным функционалом выполнения тренировки
- [x] ✅ Модели `WorkoutStep`, `WorkoutState`, `WorkoutStepState` добавлены
- **Отличия от основного приложения:** На часах отображается только текущий этап тренировки
- [ ] **TODO:** Проверить и добавить недостающие локализованные строки (`Watch.Workout.*`), добавить переводы на русский и английский

#### 6.5 Навигация и главный файл приложения ✅ Выполнено
- [x] ✅ `SotkaWatchApp.swift` настроен с навигацией и проверкой авторизации

### Этап 7: UI/UX оптимизация для часов

#### 7.1 Адаптация дизайна ✅ Частично выполнено
- [x] ✅ Минималистичный дизайн для маленького экрана (реализован в основных экранах)
- [x] ✅ Крупные кнопки для удобного нажатия (реализованы в основных экранах)
- [ ] Оптимизация шрифтов для читаемости
- [x] ✅ Использование системных цветов и иконок (реализовано)
- [x] ✅ Поддержка темной темы (автоматически через системные цвета)

#### 7.2 Обратная связь ✅ Частично выполнено
- [ ] Haptic feedback при действиях
- [x] ✅ Визуальная обратная связь (анимации реализованы в основных экранах)
- [x] ✅ Индикаторы загрузки и синхронизации (реализованы через `ProgressView()`)
- [x] ✅ Сообщения об ошибках (реализованы через `.alert` с `viewModel.error`)

### Этап 8: Финальное тестирование и документация

#### 8.1 Интеграционные тесты
- [ ] Тесты синхронизации между часами и iPhone (моки)
- [ ] Тесты обработки команд WatchConnectivity
- [ ] Тесты обработки ошибок при отсутствии связи с iPhone (показ сообщений об ошибках, блокировка действий)

#### 8.2 UI-тесты (опционально)
- [ ] Тесты основных сценариев использования
- [ ] Тесты навигации между экранами
- [ ] Тесты выбора активности
- [ ] Тесты выполнения тренировки

#### 8.3 Тестирование на устройствах
- [ ] Тестирование на реальных часах (разные модели)
- [ ] Тестирование синхронизации между часами и iPhone
- [ ] Тестирование обработки ошибок при отсутствии связи с iPhone
- [ ] Тестирование производительности

#### 8.4 Документация
- [ ] Обновление `feature-map.md` с информацией о часах
- [ ] Создание документации по архитектуре часов (если нужно)
- [ ] Документация API WatchConnectivity
- [ ] Инструкции по тестированию

#### 8.5 Оптимизация
- [ ] Оптимизация размера приложения
- [ ] Оптимизация производительности
- [ ] Оптимизация энергопотребления
- [ ] Оптимизация синхронизации

#### 8.6 Финальная проверка
- [ ] Проверка всех функций
- [ ] Проверка синхронизации
- [ ] Проверка обработки ошибок при отсутствии связи с iPhone
- [ ] Проверка на разных моделях часов
- [ ] Проверка локализации (русский и английский)
- [ ] Проверка логирования (русский язык)
- [ ] Проверка безопасного извлечения опционалов (нет force unwrap)

## Технические детали

### Модели данных

#### Модели с Codable для передачи данных

**Модели с Codable:**
- `WorkoutResult` - результат тренировки (count, duration)
- `WorkoutPreviewTraining` - данные упражнения в тренировке
- `WorkoutData` - данные тренировки (day, executionType, trainings, plannedCount)
- `WorkoutDataResponse` - полные данные тренировки с iPhone (workoutData, executionCount, comment)

**Примечание:**
- Простые структуры получают Codable для передачи через WatchConnectivity, enum'ы передаются через rawValue (Int)
- Модели размещены в общих моделях (`Models/SWSharedModels/`) или добавлены в Watch App target

### Команды WatchConnectivity

```swift
extension Constants {
    /// Команды для обмена данными между часами и iPhone через WatchConnectivity
    enum WatchCommand: String {
        // От часов к iPhone
        case setActivity = "WATCH_COMMAND_SET_ACTIVITY"
        case saveWorkout = "WATCH_COMMAND_SAVE_WORKOUT"
        case getCurrentActivity = "WATCH_COMMAND_GET_CURRENT_ACTIVITY"
        case getWorkoutData = "WATCH_COMMAND_GET_WORKOUT_DATA"
        case deleteActivity = "WATCH_COMMAND_DELETE_ACTIVITY"
        
        // От iPhone к часам
        case currentActivity = "PHONE_COMMAND_CURRENT_ACTIVITY"
        case sendWorkoutData = "PHONE_COMMAND_SEND_WORKOUT_DATA"
        case currentStatus = "PHONE_COMMAND_CURRENT_STATUS"
    }
}
```

**Примечание:** Enum `Constants.WatchCommand` находится в файле `SwiftUI-SotkaApp/Models/SWSharedModels/Constants.swift` и доступен обоим таргетам (основному приложению и Watch App).

### Формат сообщений WatchConnectivity

**Установка активности:**
```json
{
    "command": "WATCH_COMMAND_SET_ACTIVITY",
    "day": 42,
    "activityType": 0
}
```

**Сохранение тренировки:**
```json
{
    "command": "WATCH_COMMAND_SAVE_WORKOUT",
    "day": 42,
    "result": {
        "count": 4,
        "duration": 1800
    },
    "executionType": 0,
    "comment": "Отличная тренировка!"
}
```
*Примечания:*
- `result` содержит сериализованный `WorkoutResult` (Codable)
- `comment` - опциональное поле, содержит комментарий к тренировке

**Удаление активности:**
```json
{
    "command": "WATCH_COMMAND_DELETE_ACTIVITY",
    "day": 42
}
```

**Примечание:** 
- Команды проверки авторизации и получения/обновления текущего дня объединены в `PHONE_COMMAND_CURRENT_STATUS` - данные передаются вместе (статус авторизации, текущий день и текущая активность)
- Команды для получения данных пользователя не нужны - часы не отображают данные пользователя

**Ответ с текущей активностью дня:**
```json
{
    "command": "PHONE_COMMAND_CURRENT_ACTIVITY",
    "day": 42,
    "activityType": 0,
    "count": null,
    "duration": null
}
```

**Уведомление об изменении статуса (через `sendMessage`):**
```json
{
    "command": "PHONE_COMMAND_CURRENT_STATUS",
    "isAuthorized": true,
    "currentDay": 42,
    "currentActivity": 0
}
```
*Примечания:*
- Команда отправляется через `sendMessage` при авторизации/логауте или изменении `currentDayCalculator`
- `isAuthorized: Bool` - обязательное поле (статус авторизации)
- `currentDay: Int?` - обязательное поле, если `isAuthorized == true`, иначе `null`
- `currentActivity: Int?` - опциональное поле (тип активности текущего дня, если активность выбрана)
- Часы получают данные только через WatchConnectivity, локальное хранение не используется

**Важно:** 
- ✅ Синхронизация данных только через `sendMessage` (отключен `updateApplicationContext`). Данные на часах получаются только из `WatchConnectivityService`, при отсутствии связи показывается `AuthRequiredView`

## Риски и митигация

### Риск 1: Ограничения WatchConnectivity ✅ Реализовано
- **Проблема:** WatchConnectivity может быть недоступен или нестабилен
- **Митигация:** ✅ Обработка ошибок через `WatchConnectivityError`, показ ошибок, блокировка действий при недоступности сессии

### Риск 2: Различия в данных между часами и iPhone
- **Проблема:** Данные на часах могут отличаться от данных на iPhone
- **Митигация:** iPhone является основным источником истины, часы получают обновления от iPhone

### Риск 3: Производительность на часах
- **Проблема:** Ограниченные ресурсы часов могут влиять на производительность
- **Митигация:** Оптимизация кода, минимальное использование ресурсов, кэширование данных

### Риск 4: Сложность синхронизации
- **Проблема:** Синхронизация между часами и iPhone может быть сложной
- **Митигация:** Простая архитектура синхронизации, четкие команды, обработка ошибок

### Риск 5: Работа часов без авторизации ✅ Реализовано
- **Проблема:** Часы могут попытаться работать без авторизации на iPhone
- **Митигация:** ✅ Проверка авторизации через `WatchAuthService`, блокировка функционала, экран `AuthRequiredView`

### Риск 6: Отсутствие связи с iPhone ✅ Реализовано
- **Проблема:** Часы могут быть недоступны для связи с iPhone
- **Митигация:** ✅ Обработка ошибок через `WatchConnectivityError`, показ ошибок, блокировка действий при недоступности сессии

### Риск 7: Синхронизация данных между iPhone и часами ✅ Решено
- **Проблема:** Необходимость синхронизации данных между iPhone и часами
- **Митигация:** ✅ Использование WatchConnectivity как единственного механизма получения данных. При отсутствии связи показывается `AuthRequiredView`

## Приоритеты разработки

### Высокий приоритет (MVP) ✅ Выполнено
1. ✅ Добавление Codable к моделям, проверка авторизации, запрос данных с iPhone
2. ✅ Отправка действий в iPhone для сохранения, главный экран, выбор типа активности
3. ✅ Обработка отсутствия связи с iPhone

### Средний приоритет ✅ Выполнено
1. ✅ Выполнение тренировки, сохранение результата, полная синхронизация данных

### Низкий приоритет (будущие улучшения)
1. Расширенная статистика тренировок
2. Интеграция с HealthKit
3. Уведомления о тренировках
4. Циферблаты с данными программы

## Отличия от реализации в старом приложении (SOTKA-OBJc)

Этот раздел описывает ключевые отличия планируемой реализации в новом приложении от реализации в старом приложении SOTKA-OBJc.

### Архитектура хранения данных

**Старое приложение (SOTKA-OBJc):**
- Часы используют **CoreData** для локального хранения данных
- Модели: `WatchDbDay`, `WatchDbTraining`, `WatchDbCustomExercise`, `WatchDbSettings`
- Данные сохраняются локально на часах с флагом `synched` для отслеживания синхронизации
- Двусторонняя синхронизация: часы работают независимо, синхронизируются периодически
- Очередь несинхронизированных данных на часах

**Новое приложение (текущее состояние):**
- Часы не хранят данные локально - все данные получаются только через WatchConnectivity в реальном времени
- iPhone - единственное хранилище данных (SwiftData), часы работают как клиент
- Синхронизация только через WatchConnectivity (`sendMessage`), при отсутствии связи показывается `AuthRequiredView`

### Формат передачи данных

**Старое приложение:**
- Используются **JSON строки** (NSString) в Dictionary
- Команды передаются как **числовые константы** (enum WATCH_COMMANDS: 0, 1, 2...)
- Данные сериализуются в JSON строку через `toJSONString()`
- Пример: `@{@"command": @"0", @"days": jsonString}`

**Новое приложение:**
- Используются **модели с Codable** для прямой передачи данных (без DTO)
- Команды передаются как **строковые enum** (WatchCommand: "WATCH_COMMAND_GET_TRAIN_LIST")
- Данные сериализуются через JSONEncoder/JSONDecoder
- Пример: `{"command": "WATCH_COMMAND_SAVE_WORKOUT", "result": {...}}`

### Команды WatchConnectivity

**Старое приложение:**
- `WATCH_COMMAND_GET_TRAIN_LIST` (0) - запрос данных тренировки
- `WATCH_COMMAND_SAVE_TRAININGS` (1) - сохранение тренировок (массив дней)
- `PHONE_COMMAND_UPDATE_CURRENT_DAY` (2) - обновление текущего дня
- `PHONE_SYNC_REQUEST` (3) - запрос синхронизации
- `PHONE_COMMAND_GET_UNSYNCED_TRAININGS` (4) - запрос несинхронизированных тренировок

**Новое приложение:**
- Расширенный набор команд с явными названиями, более детальное разделение команд (отдельно для активности и тренировки)
- Команды проверки авторизации не нужны - статус передается через WatchConnectivity (`sendMessage`)

### Авторизация

**Старое приложение:**
- Не видно явной проверки авторизации при запуске часов
- Часы могут работать без явной проверки статуса авторизации

**Новое приложение:**
- Обязательная проверка авторизации при запуске, блокировка функционала, экран `AuthRequiredView`
- Статус авторизации передается через WatchConnectivity

### Обработка данных тренировки

**Старое приложение:**
- Данные тренировки передаются как `WatchObject` (JSON строка)
- Сохранение тренировок происходит пакетами (массив дней)
- Локальное сохранение на часах перед синхронизацией

**Новое приложение:**
- Данные тренировки передаются через модели с Codable (`WorkoutData`, `WorkoutResult`)
- Сохранение по одной активности/тренировке, немедленная передача в iPhone без локального сохранения

### Синхронизация

**Старое приложение:**
- Двусторонняя синхронизация с флагом `synched`
- Часы могут работать офлайн с последующей синхронизацией
- Очередь несинхронизированных данных на часах
- iPhone может запрашивать несинхронизированные данные с часов

**Новое приложение:**
- Односторонняя передача данных: часы → iPhone (для сохранения)
- Часы запрашивают данные с iPhone в реальном времени, нет очереди синхронизации
- При отсутствии связи показывается ошибка, действия не выполняются

### Технологии

**Старое приложение:**
- Objective-C
- CoreData на часах
- UIKit для часов (WatchKit)
- JSON строки для передачи данных

**Новое приложение:**
- Swift 6.0
- SwiftData на iPhone (не используется на часах)
- SwiftUI для часов
- Codable модели для прямой передачи данных (без DTO)

### Преимущества нового подхода

1. **Упрощенная архитектура:**
   - Нет дублирования данных между часами и iPhone
   - Нет конфликтов данных
   - Проще поддержка и отладка

2. **Актуальность данных:**
   - Данные всегда актуальны (запрашиваются в реальном времени)
   - Нет рассинхронизации между устройствами

3. **Безопасность:**
   - Обязательная проверка авторизации
   - Данные хранятся только на iPhone

4. **Современные технологии:**
   - SwiftUI вместо WatchKit
   - SwiftData вместо CoreData
   - Codable модели вместо ручной сериализации JSON и DTO

### Недостатки нового подхода

1. **Зависимость от связи:**
   - Часы не могут работать полностью офлайн
   - Требуется постоянная связь с iPhone для работы

2. **Производительность:**
   - Каждый запрос требует связи с iPhone
   - Может быть медленнее при плохой связи

3. **Ограничения:**
   - Меньше автономности часов
   - Зависимость от доступности iPhone

## Рефакторинг архитектуры WatchConnectivity

**Важно:** Рефакторинг выполняется с соблюдением правил TDD (Test-Driven Development) и unit-тестирования:
- **TDD цикл**: Красный (тест падает) → Зеленый (код проходит тест) → Рефакторинг
- **Итеративный процесс**: Тест → Код → `make format` → `make test` → Следующий тест
- **Технологии**: Swift Testing (`import Testing`), `@Test`, `#expect`, `#require`
- **Моки**: Использование моков для всех зависимостей (WCSession, сервисы)
- **Описания тестов**: Все тесты с описанием на русском языке в аннотации `@Test`

### Анализ текущих проблем

#### Проблема 1: Смешение ответственности в WatchConnectivityManager

**Текущее состояние:**
- `WatchConnectivityManager` - вложенный класс в `StatusManager`, выполняет слишком много функций:
  - Управляет WCSession (является делегатом)
  - Хранит очередь запросов (`pendingRequests`)
  - Обрабатывает команды от часов (бизнес-логика)
  - Отправляет данные на часы
  - Работает с `ModelContext` (что странно для менеджера связи)
- Нарушение принципа единственной ответственности (Single Responsibility Principle)

**Проблемы:**
- Менеджер связи не должен знать о бизнес-логике приложения
- Сложно тестировать из-за множества зависимостей
- Сложно поддерживать из-за смешения уровней абстракции

#### Проблема 2: Костыль с очередью запросов

**Текущее состояние:**
- Делегат WCSession (`nonisolated`) добавляет запросы в очередь через `Task { @MainActor in }`
- Очередь обрабатывается во вьюхе через `onChange(of: pendingRequestsCount)`
- Сложный и непредсказуемый поток данных: делегат → очередь → вьюха → обработка

**Проблемы:**
- Непредсказуемый порядок обработки запросов
- Зависимость от SwiftUI lifecycle для обработки запросов
- Сложность отладки из-за асинхронности и очереди
- Потенциальные проблемы с производительностью при большом количестве запросов

**Код-костыль:**
```swift
// В SwiftUI_SotkaAppApp.swift
.onChange(of: statusManager.watchConnectivityManager.pendingRequestsCount) { _, _ in
    guard authHelper.isAuthorized else { return }
    statusManager.watchConnectivityManager.processPendingRequests(context: modelContainer.mainContext)
}
```

#### Проблема 3: Force unwrap watchConnectivityManager

**Текущее состояние:**
- `@ObservationIgnored var watchConnectivityManager: WatchConnectivityManager!` в `StatusManager`
- Инициализация происходит в `init` после создания всех свойств
- Использование `unowned` reference для избежания циклической ссылки

**Проблемы:**
- Force unwrap может привести к крашу, если инициализация не удалась
- Неявная зависимость от порядка инициализации
- Нарушение принципа безопасного программирования

**Код-проблема:**
```swift
@ObservationIgnored var watchConnectivityManager: WatchConnectivityManager!

init(...) {
    // ...
    unowned let tempStatusManager = self
    self.watchConnectivityManager = WatchConnectivityManager(
        statusManager: tempStatusManager,
        sessionProtocol: watchConnectivitySessionProtocol
    )
}
```

#### Проблема 4: Неоптимальный поток данных

**Текущий поток:**
1. Часы отправляют команду → WCSessionDelegate (nonisolated)
2. Делегат добавляет запрос в очередь через `Task { @MainActor in }`
3. Вьюха отслеживает изменения очереди через `onChange`
4. Вьюха вызывает `processPendingRequests(context:)`
5. Менеджер обрабатывает запросы и работает с `ModelContext`

**Проблемы:**
- Слишком много промежуточных шагов
- Зависимость от SwiftUI lifecycle
- Непредсказуемое время обработки
- Сложность отладки

### Предлагаемое решение

#### Принципы рефакторинга

1. **Разделение ответственности (Separation of Concerns)**
   - `StatusManager` - делегат WCSession, обрабатывает команды от часов
   - `WatchConnectivityManager` - простой сервис только для отправки данных на часы
   - Убрать бизнес-логику из менеджера связи

2. **Прямая обработка команд (Command Pattern)**
   - Убрать очередь запросов
   - Обрабатывать команды сразу в делегате WCSession
   - Использовать Command Pattern для обработки команд

3. **Безопасная инициализация и value types**
   - Убрать force unwrap
   - `WatchConnectivityManager` - структура (value type), так как не хранит состояние
   - Протокол `WatchConnectivityManagerProtocol` для тестирования `StatusManager`
   - Явные зависимости через конструктор

4. **Упрощение потока данных**
   - Делегат WCSession → прямая обработка команды → ответ на часы
   - Убрать промежуточные шаги
   - Предсказуемый и синхронный поток

#### Архитектура после рефакторинга

```
┌─────────────────────────────────────────────────────────┐
│                    StatusManager                        │
│  (WCSessionDelegate, содержит все сервисы)             │
│                                                         │
│  - session(_:didReceiveMessage:)                       │
│    → handleWatchCommand(_:context:replyHandler:)      │
│      → dailyActivitiesService / progressSyncService    │
│                                                         │
│  - sendCurrentStatus(isAuthorized:currentDay:currentActivity:) │
│  - sendCurrentActivity(day:context:)                   │
└─────────────────────────────────────────────────────────┘
                          │
                          │ использует
                          ▼
┌─────────────────────────────────────────────────────────┐
│      WatchConnectivityManager (struct)                   │
│  (Простой сервис только для отправки данных)            │
│                                                         │
│  - sendMessage(_:replyHandler:errorHandler:)            │
│  - Управление WCSession (активация, проверка доступности)│
│                                                         │
│  Реализует протокол WatchConnectivityManagerProtocol   │
│  для тестирования StatusManager                         │
└─────────────────────────────────────────────────────────┘
```

#### Преимущества нового подхода

1. **Простота и понятность**
   - Прямой поток данных без промежуточных шагов
   - Легко понять, где и как обрабатываются команды
   - Меньше кода, меньше сложности

2. **Тестируемость**
   - Протокол `WatchConnectivityManagerProtocol` для мокирования в тестах `StatusManager`
   - `WatchConnectivityManager` как структура - безопаснее и проще
   - Легко тестировать обработку команд в `StatusManager`
   - Четкое разделение ответственности

3. **Безопасность**
   - Нет force unwrap
   - Явные зависимости
   - Предсказуемое поведение

4. **Производительность**
   - Нет очереди запросов
   - Немедленная обработка команд
   - Меньше накладных расходов

### Пошаговый план рефакторинга

#### Шаг 1: Создание простого WatchConnectivityManager ✅

**Цель:** Создать простую структуру только для отправки данных на часы

**Действия (TDD подход):**

**1.1. Красный - Написать тесты (до реализации):** ✅
1. ✅ Создать файл `WatchConnectivityManagerProtocolTests.swift` (создан файл с тестами для протокола)
2. ✅ Написать тесты для протокола `WatchConnectivityManagerProtocol`:
   - ✅ `@Test("Должен отправлять сообщение через WCSession")` - тест `sendMessage`
   - ✅ `@Test("Должен возвращать isReachable из WCSession")` - тест `isReachable`
   - ✅ `@Test("Должен вызывать errorHandler при ошибке отправки")` - дополнительный тест
   - ✅ `@Test("Должен вызывать errorHandler когда сессия недоступна")` - дополнительный тест
   - ✅ Использовать `MockWCSession` для мокирования WCSession
   - ✅ Использовать `#expect` для проверок, `#require` для разворачивания опционалов
3. ✅ Запустить `make test` - тесты проходят (Зеленый)

**1.2. Зеленый - Реализовать код:** ✅
1. ✅ Создать протокол `WatchConnectivityManagerProtocol` с методами:
   - ✅ `sendMessage(_:replyHandler:errorHandler:)`
   - ✅ `isReachable` (computed property)
   - ✅ **Примечание:** Методы активации сессии НЕ нужны - активация происходит в `StatusManager`
2. ✅ Создать отдельный файл `WatchConnectivityManager.swift` со структурой (не класс)
3. ✅ Реализовать структуру `WatchConnectivityManager`, которая:
   - ✅ Хранит `WCSessionProtocol?` (опциональное свойство для поддержки iPad/macOS, где WCSession может быть не поддерживается)
   - ✅ Реализует `WatchConnectivityManagerProtocol`
   - ✅ Содержит только методы отправки данных на часы
   - ✅ Не хранит состояние (поэтому структура, а не класс)
   - ✅ **Не является делегатом WCSession** (делегатом будет `StatusManager`)
   - ✅ **Безопасная инициализация:** не использует `fatalError`, если WCSession не поддерживается, `sessionProtocol` будет `nil`
   - ✅ `isReachable` возвращает `false` если `sessionProtocol == nil`
   - ✅ `sendMessage` вызывает `errorHandler` если `sessionProtocol == nil`
4. ✅ Создать enum `WatchConnectivityError` в extension `WatchConnectivityManager`:
   - ✅ Кейсы: `.unsupported` (WCSession не поддерживается) и `.unreachable` (сессия недоступна)
   - ✅ Реализует `LocalizedError` с описаниями ошибок
   - ✅ Используется вместо локальных структур ошибок в методе `sendMessage`
5. ✅ Добавить тесты для случая когда `sessionProtocol == nil`:
   - ✅ `@Test("Должен возвращать false для isReachable когда sessionProtocol равен nil")`
   - ⚠️ Тест для `errorHandler` с `.unsupported` не добавлен, так как его нельзя надежно протестировать на всех устройствах (поведение зависит от `WCSession.isSupported()`, которое мы не контролируем в тестах)
6. ✅ Запустить `make format` и `make test` - тесты проходят (Зеленый)

**Результат:** ✅
- ✅ Простая структура с единственной ответственностью - отправка данных
- ✅ Протокол для легкого тестирования `StatusManager`
- ✅ Value type - безопаснее и проще
- ✅ **Структура остается структурой**, так как делегатом WCSession будет `StatusManager`
- ✅ Безопасная работа на iPad/macOS (без `fatalError`, `sessionProtocol` может быть `nil`)
- ✅ Централизованная обработка ошибок через enum `WatchConnectivityError` в extension

#### Шаг 2: Перенос делегата WCSession в StatusManager

**Цель:** Сделать `StatusManager` делегатом WCSession для прямой обработки команд

**Действия (TDD подход):**

**2.1. Красный - Написать тесты (до реализации):**
1. Создать файл `StatusManagerWatchConnectivityTests.swift`
2. Написать тесты для методов делегата:
   - `@Test("Должен обрабатывать активацию WCSession")` - тест `session(_:activationDidCompleteWith:error:)`
   - `@Test("Должен обрабатывать сообщение от часов")` - тест `session(_:didReceiveMessage:)`
   - `@Test("Должен обрабатывать сообщение с replyHandler")` - тест `session(_:didReceiveMessage:replyHandler:)`
3. Написать тесты для методов отправки данных:
   - `@Test("Должен отправлять текущий статус в начале getStatus")` - тест `sendCurrentStatus` сразу после первой установки `currentDayCalculator` (до синхронизации, активность может быть `nil`)
   - `@Test("Должен отправлять текущий статус после синхронизации в getStatus")` - тест `sendCurrentStatus` перед `didLoadInitialData = true` (после синхронизации, активность может появиться)
   - `@Test("Должен отправлять текущий статус при изменении currentDayCalculator")` - тест `sendCurrentStatus` из `.onChange(of: currentDayCalculator)`
   - `@Test("Должен отправлять текущий статус при логауте")` - тест `sendCurrentStatus` из `processAuthStatus` с `isAuthorized == false`
   - `@Test("Должен отправлять текущую активность")` - тест `sendCurrentActivity`
4. Использовать `MockWCSession` и `MockWatchConnectivityManager` для тестирования
5. Запустить `make test` - тесты должны падать (Красный)

**2.2. Зеленый - Реализовать код:**
1. Добавить `WCSessionDelegate` к `StatusManager`
2. В `init` `StatusManager`:
   - Получить `WCSession.default` (или использовать `WCSessionProtocol` для тестирования)
   - Установить `StatusManager` как делегат: `session.delegate = self`
   - Активировать сессию: `session.activate()`
3. Перенести методы делегата из `WatchConnectivityManager` в `StatusManager`:
   - `session(_:activationDidCompleteWith:error:)` - обработка активации
   - `session(_:didReceiveMessage:)` → `handleWatchCommand(_:context:)`
   - `session(_:didReceiveMessage:replyHandler:)` → `handleWatchCommand(_:context:replyHandler:)`
4. Создать метод `handleWatchCommand(_:context:replyHandler:)` для обработки всех команд (пока заглушка)
5. Создать методы отправки данных на часы в `StatusManager`:
6. Обновить метод `getStatus` для вызова `sendCurrentStatus`:
   - Добавить вызов `sendCurrentStatus` сразу после первой установки `currentDayCalculator = .init(startDate, now)` (до синхронизации)
   - Добавить вызов `sendCurrentStatus` перед `didLoadInitialData = true` (после синхронизации, после второй установки `currentDayCalculator`)
   - В обоих случаях пытаться получить `currentActivity` из SwiftData для текущего дня (может быть `nil`)
7. Обновить метод `processAuthStatus`:
   - При `isAuthorized == false` вызывать `sendCurrentStatus(isAuthorized: false, currentDay: nil, currentActivity: nil)`
   - Убрать старый вызов `sendAuthStatusChanged` (если был)
8. Обновить метод `sendDayDataToWatch`:
   - Заменить вызов `sendCurrentDayChanged` на `sendCurrentStatus` с получением `currentActivity` из SwiftData
   - `sendCurrentStatus(isAuthorized:currentDay:currentActivity:)` - отправка статуса авторизации, текущего дня и текущей активности (опционально):
     - **Вызывается из `getStatus`** в двух местах:
       - **Сразу после первой установки `currentDayCalculator = .init(startDate, now)`** (в начале метода `getStatus`, до синхронизации):
         - Получить `currentDay` из `currentDayCalculator?.currentDay`
         - Попытаться получить `currentActivity` из SwiftData для текущего дня (может быть `nil`, если активность еще не выбрана)
         - Отправить `isAuthorized: true`, `currentDay`, `currentActivity` (опционально)
       - **Перед `didLoadInitialData = true`** (после синхронизации, после второй установки `currentDayCalculator = .init(startDate, now)`):
         - Получить `currentDay` из `currentDayCalculator?.currentDay`
         - Попытаться получить `currentActivity` из SwiftData для текущего дня (после синхронизации активность может появиться)
         - Отправить `isAuthorized: true`, `currentDay`, `currentActivity` (опционально)
     - **Вызывается из `.onChange(of: currentDayCalculator)`** в `SwiftUI_SotkaAppApp.swift` (через `sendDayDataToWatch`):
       - Получить `currentDay` из параметра
       - Получить `currentActivity` из SwiftData для текущего дня (если активность выбрана)
       - Отправить `isAuthorized: true` (так как метод вызывается только для авторизованных пользователей)
     - **Вызывается из `processAuthStatus`** при `isAuthorized == false`:
       - Отправить `isAuthorized: false`, `currentDay: nil`, `currentActivity: nil`
     - Параметры: `isAuthorized: Bool` (обязательный), `currentDay: Int?` (обязательный, если авторизован), `currentActivity: DayActivityType?` (опциональный, получается из SwiftData для текущего дня)
   - `sendCurrentActivity(day:context:)` - отправка активности конкретного дня (вызывается после обработки команд `setActivity`, `saveWorkout`, `deleteActivity` для отправки обновления на часы)

**Результат:**
- Прямая обработка команд без очереди
- `StatusManager` имеет доступ ко всем сервисам для обработки команд
- `StatusManager` управляет жизненным циклом WCSession (активация, делегат)
- Методы отправки данных на часы реализованы в `StatusManager` и используют `watchConnectivityManager`

#### Шаг 3: Убрать force unwrap и очередь

**Цель:** Безопасная инициализация и убрать костыль с очередью, удалить старый класс `StatusManager.WatchConnectivityManager`

**Действия (TDD подход):**

**3.1. Красный - Написать тесты (до реализации):**
1. Добавить тесты в `StatusManagerWatchConnectivityTests.swift`:
   - `@Test("Должен инициализировать watchConnectivityManager без force unwrap")` - проверка безопасной инициализации
   - `@Test("Должен работать без очереди запросов")` - проверка отсутствия очереди
2. Запустить `make test` - тесты должны падать (Красный)

**3.2. Зеленый - Реализовать код:**
1. Изменить `watchConnectivityManager` на свойство типа `WatchConnectivityManagerProtocol` (не force unwrap)
2. Инициализировать новый `WatchConnectivityManager` (структуру) в `init` `StatusManager` как обычное свойство
3. Удалить старый класс `StatusManager.WatchConnectivityManager` (extension в `StatusManager.swift`)
4. Убрать `pendingRequests` и `pendingRequestsCount` из старого класса
5. Убрать метод `processPendingRequests(context:)` из старого класса
6. Убрать `onChange(of: pendingRequestsCount)` из `SwiftUI_SotkaAppApp.swift`
7. Убрать enum `WatchRequest` (больше не нужен)
8. Убрать `unowned` reference (больше не нужна, так как структура не создает циклических ссылок)
9. Убрать методы обработки команд из старого класса (`handleSetActivity`, `handleSaveWorkout`, `handleGetCurrentActivity`, `handleGetWorkoutData`, `handleDeleteActivity`)
10. Убрать методы делегата WCSession из старого класса (они будут перенесены в `StatusManager` в Шаге 2)
11. Запустить `make format` и `make test` - тесты должны пройти (Зеленый)

**Результат:**
- Нет force unwrap
- Нет очереди запросов
- Старый класс `StatusManager.WatchConnectivityManager` удален
- Используется новая структура `WatchConnectivityManager` через протокол
- Простой и предсказуемый поток данных
- Использование протокола для гибкости и тестируемости

**3.3. Рефакторинг:** ✅
> **Примечание:** Новый `WatchConnectivityManager` создан с нуля и не содержит бизнес-логики. Старый класс `StatusManager.WatchConnectivityManager` был удален в этом шаге вместе с очередью запросов и методами обработки команд.

#### Шаг 4: Рефакторинг обработки команд

**Цель:** Упростить обработку команд с использованием Command Pattern

**Действия (TDD подход, итеративно для каждой команды):**

**4.1. Красный - Написать тесты для парсинга:**
1. Добавить тесты в `StatusManagerWatchConnectivityTests.swift`:
   - `@Test("Должен парсить команду setActivity из Dictionary")` - тест `parseWatchCommand` для `.setActivity`
   - `@Test("Должен парсить команду saveWorkout из Dictionary")` - тест `parseWatchCommand` для `.saveWorkout`
   - `@Test("Должен возвращать nil для неизвестной команды")` - тест обработки ошибок
2. Запустить `make test` - тесты должны падать (Красный)

**4.2. Зеленый - Реализовать парсинг:**
1. **Использовать существующий `Constants.WatchCommand`** (enum с rawValue String) для парсинга команды из Dictionary
2. Создать метод `parseWatchCommand(_:) -> (command: Constants.WatchCommand, data: [String: Any])?` для парсинга сообщений:
   - Извлечь команду через `Constants.WatchCommand(rawValue: commandString)`
   - Вернуть команду и данные для дальнейшей обработки
3. Запустить `make format` и `make test` - тесты должны пройти (Зеленый)

**4.3. Красный - Написать тесты для обработки команд (итеративно):**
Для каждой команды (setActivity, saveWorkout, getCurrentActivity, getWorkoutData, deleteActivity):
1. Добавить тесты в `StatusManagerWatchConnectivityTests.swift`:
   - `@Test("Должен обрабатывать команду setActivity")` - тест обработки команды
   - `@Test("Должен отправлять текущую активность после setActivity")` - тест отправки обновления
   - Использовать `MockWatchConnectivityManager` для проверки вызовов
2. Запустить `make test` - тесты должны падать (Красный)

**4.4. Зеленый - Реализовать обработку команд (итеративно):**
1. Создать метод `handleWatchCommand(_:context:replyHandler:)` с switch по типам команд из `Constants.WatchCommand`
2. Для каждой команды:
   - Парсить данные из Dictionary
   - Обрабатывать команду напрямую без очереди
   - Перенести логику из `WatchConnectivityManager` в `StatusManager`
3. После обработки команд, которые изменяют активность (`setActivity`, `saveWorkout`, `deleteActivity`):
   - Вызывать `sendCurrentActivity(day:context:)` для отправки обновленной активности на часы
   - **Если измененная активность относится к текущему дню** (день совпадает с `currentDayCalculator?.currentDay`):
     - Также вызвать `sendCurrentStatus()` для обновления статуса на часах с новой активностью текущего дня
4. Использовать `watchConnectivityManager` только для отправки ответов на часы через методы `sendCurrentStatus()` и `sendCurrentActivity()`
5. Запустить `make format` и `make test` - тесты должны пройти (Зеленый)

**4.5. Рефакторинг:**
1. Улучшить код после успешных тестов
2. Убрать дублирование
3. Запустить `make format` и `make test` - убедиться, что все тесты проходят

**Результат:**
- Четкая структура обработки команд
- Легко добавлять новые команды
- Легко тестировать обработку команд
- Автоматическая отправка обновлений на часы после изменения активности

#### Шаг 5: Обновление тестов

**Цель:** Обновить тесты под новую архитектуру и обеспечить полное покрытие

**Действия:**
1. Обновить тесты `WatchConnectivityManagerTests`:
   - Убрать тесты обработки команд (перенесены в `StatusManager`)
   - Оставить только тесты отправки данных (структура)
   - Запустить `make test` - убедиться, что тесты проходят
2. Создать мок `MockWatchConnectivityManager`, реализующий `WatchConnectivityManagerProtocol`:
   - В папке `SwiftUI-SotkaAppTests/Mocks/`
   - Использовать для тестирования `StatusManager`
3. Убедиться, что все тесты в `StatusManagerWatchConnectivityTests` написаны согласно правилам:
   - Все тесты с описанием на русском языке в `@Test("...")`
   - Использование `#expect` для проверок
   - Использование `#require` для разворачивания опционалов
   - Использование `MockWatchConnectivityManager` и `MockWCSession` для мокирования
   - Тесты обработки команд от часов (уже написаны в Шаге 4)
   - Тесты отправки данных на часы:
     - `@Test("Должен отправлять текущий статус в начале getStatus")` - тест `sendCurrentStatus()` сразу после первой установки `currentDayCalculator` (до синхронизации, активность может быть `nil`)
     - `@Test("Должен отправлять текущий статус после синхронизации в getStatus")` - тест `sendCurrentStatus()` перед `didLoadInitialData = true` (после синхронизации, активность может появиться)
     - `@Test("Должен отправлять текущий статус при изменении currentDayCalculator")` - тест `sendCurrentStatus()` из `.onChange(of: currentDayCalculator)`
     - `@Test("Должен отправлять текущий статус при логауте")` - тест `sendCurrentStatus()` из `processAuthStatus` с `isAuthorized == false`
     - `@Test("Должен отправлять текущую активность после изменения")` - тест `sendCurrentActivity()`
   - Тесты обработки ошибок:
     - `@Test("Должен обрабатывать неизвестную команду")` - тест обработки ошибок парсинга
     - `@Test("Должен обрабатывать неверный формат команды")` - тест обработки ошибок валидации
4. Обновить моки:
   - Упростить `MockWCSession` (убрать логику очереди)
   - Использовать `MockWatchConnectivityManager` в тестах `StatusManager`
5. Запустить `make format` и `make test` - все тесты должны проходить

**Результат:**
- Все тесты проходят
- Покрытие тестами новой архитектуры
- Легко добавлять новые тесты

#### Шаг 6: Обновление документации

**Цель:** Обновить документацию под новую архитектуру

**Действия:**
1. Обновить раздел "Архитектура" в `apple-watch-development-plan.md`
2. Обновить описание `WatchConnectivityManager` (теперь простой сервис)
3. Обновить описание обработки команд (теперь в `StatusManager`)
4. Обновить примеры кода в документации

**Результат:**
- Актуальная документация
- Понятное описание новой архитектуры

### Риски и митигация

#### Риск 1: Проблемы с actor isolation

**Проблема:** Делегат WCSession `nonisolated`, а обработка команд требует `@MainActor`

**Митигация:**
- Использовать `Task { @MainActor in }` для перехода в MainActor
- Использовать `nonisolated(unsafe)` для безопасного доступа к данным
- Тестировать на разных сценариях

#### Риск 2: Потеря команд при быстрых запросах

**Проблема:** При быстрых запросах команды могут обрабатываться не в том порядке

**Митигация:**
- WatchConnectivity гарантирует порядок доставки сообщений
- Если нужна гарантия порядка - добавить последовательную обработку через Actor
- Тестировать сценарии с множественными запросами

#### Риск 3: Регрессии в существующем функционале

**Проблема:** При рефакторинге может сломаться существующий функционал

**Митигация:**
- Пошаговый рефакторинг с тестами на каждом шаге
- Сохранение существующих тестов до завершения рефакторинга
- Тщательное тестирование на реальных устройствах

### Ожидаемые результаты

После рефакторинга:

1. **Упрощение кода:**
   - Убрано ~200 строк кода (очередь, обработка во вьюхе)
   - Проще понять поток данных
   - Меньше промежуточных шагов

2. **Улучшение архитектуры:**
   - Четкое разделение ответственности
   - Легко тестировать и поддерживать
   - Соответствие принципам SOLID

3. **Безопасность:**
   - Нет force unwrap
   - Явные зависимости
   - Предсказуемое поведение

4. **Производительность:**
   - Нет очереди запросов
   - Немедленная обработка команд
   - Меньше накладных расходов

## Заключение

Этот план описывает детальную разработку приложения для Apple Watch с сокращенным функционалом по сравнению с основным iOS-приложением. Основные компоненты:

1. **Авторизация** - проверка статуса авторизации и блокировка функционала без авторизации
2. **Получение текущего дня** - номер дня передается только через WatchConnectivity, при отсутствии связи показывается `AuthRequiredView`
3. **Запрос данных с iPhone** - данные активности и тренировок запрашиваются с iPhone в реальном времени
4. **Сохранение через iPhone** - все действия передаются в iPhone для сохранения в SwiftData
5. **Главный экран, выбор активности, выполнение тренировки** - упрощенный интерфейс для работы с активностями и тренировками

### Ключевые принципы

**Текущее состояние:**
- iPhone приложение - единственное хранилище данных (SwiftData)
- Часы как клиент - запрашивают данные с iPhone и отправляют действия для сохранения
- Обязательная авторизация, синхронизация только через WatchConnectivity (`sendMessage`)
- Данные на часах получаются только через `WatchConnectivityService`, при отсутствии связи показывается `AuthRequiredView`

