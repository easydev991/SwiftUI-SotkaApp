# План разработки приложения для Apple Watch

## Обзор

Этот документ описывает детальный план разработки приложения для Apple Watch с сокращенным функционалом по сравнению с основным iOS-приложением. Приложение для часов будет поддерживать выбор типа активности на день и выполнение тренировок с синхронизацией данных между часами и iPhone.

## Цели и ограничения

### Функционал для часов
- Выбор типа активности на сегодняшний день из 4 вариантов (`DayActivityType`):
  - `workout` - тренировка
  - `stretch` - растяжка
  - `rest` - отдых
  - `sick` - болезнь
- Выполнение тренировки (если выбран тип `workout`):
  - Упрощенный интерфейс выполнения тренировки
  - Сохранение результата тренировки
- Синхронизация данных между часами и iPhone:
  - Двусторонняя синхронизация через WatchConnectivity
  - Синхронизация выбранных активностей
  - Синхронизация результатов тренировок
  - Синхронизация текущего дня программы

### Ограничения
- Минимальный UI для часов (ограниченный размер экрана)
- Упрощенная логика тренировок (без сложных настроек)
- **Часы не хранят данные локально** - все данные запрашиваются с iPhone и сохраняются через iPhone в SwiftData
- **Статус авторизации и `startDate`** читаются напрямую из App Group UserDefaults (см. раздел 1.3)
- **Текущий день** вычисляется локально на часах из `startDate` с помощью `DayCalculator`
- **iPhone приложение является единственным хранилищем данных** (SwiftData)
- **Приложение для часов работает только после успешной авторизации в iPhone приложении**

## Архитектура

### Структура проекта

```
SotkaWatch Watch App/
├── Models/
│   └── AuthState.swift                 # Модель состояния авторизации для Watch App ✅
├── Services/
│   ├── WatchAuthService.swift          # Сервис авторизации для Watch App ✅
│   ├── WatchAuthServiceProtocol.swift  # Протокол сервиса авторизации ✅
│   ├── WatchConnectivityService.swift  # Сервис связи с iPhone через WatchConnectivity ✅
│   ├── WatchConnectivityServiceProtocol.swift # Протокол сервиса связи ✅
│   ├── WatchWorkoutService.swift       # Сервис тренировок для Watch App ✅
│   └── WCSessionProtocol.swift         # Протокол для WCSession (для тестирования) ✅
├── ViewModels/
│   ├── HomeViewModel.swift              # ViewModel для главного экрана ✅
│   └── WorkoutViewModel.swift          # ViewModel для экрана тренировки ✅
├── Views/
│   ├── AuthRequiredView.swift          # Экран для неавторизованных пользователей ✅
│   ├── HomeView.swift                  # Главный экран часов ✅
│   ├── DayActivityView.swift           # Экран активности дня (выбор/отображение) ✅
│   ├── DayActivitySelectionView.swift  # Выбор типа активности ✅
│   ├── SelectedActivityView.swift      # Отображение выбранной активности ✅
│   ├── WatchDayActivityTrainingView.swift # Компонент отображения данных тренировки ✅
│   ├── WatchDayActivityCommentView.swift  # Компонент отображения комментария ✅
│   ├── WorkoutView.swift               # Экран выполнения тренировки (еще не создан)
│   └── WorkoutRestTimerView.swift      # Таймер отдыха между кругами/подходами (еще не создан)
└── Utilities/
    ├── WatchAppGroupHelper.swift       # Утилита для работы с App Group UserDefaults ✅
    └── WatchAppGroupHelperProtocol.swift # Протокол утилиты (для тестирования) ✅

Примечание: 
- Модели данных используются из основного приложения:
  - Models/SWSharedModels/WorkoutData.swift (общая модель для передачи данных тренировки)
  - Models/SWSharedModels/WorkoutDataResponse.swift (структура для передачи полных данных тренировки с iPhone на Apple Watch, включает WorkoutData, executionCount, comment)
  - Models/Workout/WorkoutResult.swift (добавлен Codable для передачи через WatchConnectivity)
  - Models/Workout/WorkoutPreviewTraining.swift (добавлен Codable для передачи через WatchConnectivity)
  - Models/Workout/DayActivityType.swift (используется rawValue для передачи)
  - Models/Workout/ExerciseExecutionType.swift (используется rawValue для передачи)
  - Models/Workout/ExerciseType.swift (добавлен в Watch App target для использования локализованных названий и иконок упражнений)
  - Models/Workout/DayCalculator.swift (переиспользуется из основного приложения для вычисления текущего дня программы)
  - **Models/Workout/WorkoutStep.swift** (добавлен в Watch App target для представления этапов тренировки: разминка, упражнение, заминка) ⚠️ **Критически важно для сохранения тех же стадий тренировки**
  - **Models/Workout/WorkoutState.swift** (добавлен в Watch App target для представления состояния этапа: active, completed, inactive) ⚠️ **Критически важно для управления этапами тренировки**
  - **Models/Workout/WorkoutStepState.swift** (добавлен в Watch App target для объединения этапа и его состояния) ⚠️ **Критически важно для отслеживания прогресса тренировки**
- Локальные модели для Watch App размещаются в `Models/` (например, `AuthState`)
- Простые структуры (не SwiftData) получают Codable для прямой передачи через WatchConnectivity
- Модели с `@Model` (SwiftData) не используются напрямую на часах
- Ассеты упражнений находятся в отдельном `ExercisesAssets.xcassets`, доступном обоим таргетам (основное приложение и Watch App)
```

### Технологии

- **SwiftUI** - для UI (watchOS поддерживает SwiftUI)
- **WatchConnectivity** - для связи с iPhone
- **UserDefaults** (App Group) - для чтения статуса авторизации и `startDate` (см. раздел 1.3)
- **DayCalculator** - модель для вычисления текущего дня программы (переиспользуется из основного приложения)
- **OSLog** - для логирования

**Важно:** 
- Часы не используют SwiftData или другое постоянное хранилище. Все данные запрашиваются с iPhone в реальном времени.
- **Модели переиспользуются из основного приложения** - не создаем дубликаты моделей для часов.
- **Простые структуры (не SwiftData)** получают Codable для прямой передачи через WatchConnectivity:
  - `WorkoutResult` - добавлен Codable
  - `WorkoutPreviewTraining` - добавлен Codable
  - `DayActivityType` и `ExerciseExecutionType` - используют rawValue для передачи
- **`ExerciseType`** добавлен в Watch App target для использования локализованных названий упражнений и иконок на экране тренировки
- **Ассеты упражнений** находятся в отдельном `ExercisesAssets.xcassets`, доступном обоим таргетам (основное приложение и Watch App), что позволяет использовать иконки упражнений без дублирования
- Модели с `@Model` (SwiftData) не используются напрямую на часах, только для преобразования в простые структуры.

### Обмен данными между часами и iPhone

#### WatchConnectivity Service

**Архитектура связи:**
- **iPhone является единственным хранилищем данных** (SwiftData)
- **Часы не хранят данные локально** - все данные запрашиваются с iPhone в реальном времени
- **Все действия с часов передаются в iPhone** для сохранения в SwiftData
- Связь выполняется через WatchConnectivity Framework
- **Чтение статуса авторизации и `startDate`** напрямую из App Group UserDefaults (см. раздел 1.3)
- **Текущий день** вычисляется локально на часах из `startDate` с помощью `DayCalculator`
- **Уведомления об изменениях статуса авторизации:**
  - iPhone отправляет команду `PHONE_COMMAND_AUTH_STATUS_CHANGED` только при логауте (при авторизации часы читают статус из App Group UserDefaults)
  - Часы также проверяют статус авторизации при активации приложения (`scenePhase == .active`) для обеспечения актуальности данных даже при отсутствии связи

**Команды синхронизации:** (см. раздел "Команды WatchConnectivity" ниже)

**Формат данных:**
- JSON для передачи сложных структур
- Простые типы (Int, String, Bool) для простых команд

#### Разрешение конфликтов при одновременном изменении активности

**Проблема:**
При одновременном изменении активности на один и тот же день с разных устройств (часы и iPhone) могут возникать конфликты. Например:
- На iPhone начали тренировку (создана активность `.workout`), но не закончили и свернули приложение
- На часах выбрали активность "отдых" для того же дня
- Без специальной обработки активность будет перезаписана на "отдых", что приведет к потере данных о тренировке

**Стратегия разрешения конфликтов:**

1. **Приоритет незавершенных тренировок:**
   - Если на день уже существует активность типа `.workout` (тренировка), изменение на другой тип активности (`.rest`, `.stretch`, `.sick`) должно быть запрещено или требовать подтверждения
   - Это предотвращает случайную потерю данных о начатой тренировке
   - Проверка выполняется на iPhone при обработке команды `WATCH_COMMAND_SET_ACTIVITY` от часов

2. **Last Write Wins (LWW) для других случаев:**
   - Для активностей типа `.rest`, `.stretch`, `.sick` применяется стратегия LWW на основе `modifyDate`
   - Последнее изменение побеждает (обновляется `modifyDate` при каждом изменении)
   - Это соответствует существующей логике разрешения конфликтов при синхронизации с сервером

3. **Проверка перед изменением:**
   - При получении команды `WATCH_COMMAND_SET_ACTIVITY` на iPhone:
     - Проверить существующую активность для указанного дня
     - Если активность существует и имеет тип `.workout`:
       - Отклонить изменение (вернуть ошибку на часы)
       - Или запросить подтверждение у пользователя (если изменение запрошено с iPhone)
     - Если активность не существует или имеет другой тип - выполнить изменение

4. **Уведомление пользователя:**
   - При попытке изменить активность на часах, если на iPhone есть незавершенная тренировка:
     - Показать сообщение об ошибке на часах: "Нельзя изменить активность: на телефоне начата тренировка"
     - Предложить завершить тренировку на телефоне или отменить её перед изменением активности

5. **Специальный случай - завершенные тренировки:**
   - Если тренировка завершена (есть `count` и `duration`), изменение на другой тип активности разрешено
   - Это позволяет пользователю изменить активность после завершения тренировки

**Реализация:**
- Логика проверки конфликтов реализуется в `WatchConnectivityManager` на iPhone при обработке команды `WATCH_COMMAND_SET_ACTIVITY`
- Используется `DailyActivitiesService` для проверки существующей активности
- При обнаружении конфликта возвращается ошибка на часы через WatchConnectivity
- Часы обрабатывают ошибку и показывают соответствующее сообщение пользователю

**Примечание:**
- Эта стратегия применяется только для конфликтов между часами и iPhone
- Конфликты при синхронизации с сервером разрешаются по существующей логике LWW в `DailyActivitiesService.downloadServerActivities()`

## Детальный план реализации

**Важно:** План следует принципам TDD (Test-Driven Development). Сначала пишутся тесты, затем реализация. UI реализуется в последнюю очередь.

### Принципы локализации для Watch App

1. **Использование общего файла локализации:**
   - Файл `SupportingFiles/Localizable.xcstrings` уже добавлен в Watch App target
   - Все строки для часов добавляются в этот же файл с префиксом `Watch.*`
   - Использование общего файла упрощает поддержку и позволяет переиспользовать общие строки

2. **Локализация displayName для часов:** ✅ Выполнено (см. раздел 1.2)

3. **Избежание дублей ключей:**
   - Перед добавлением новых ключей обязательно проверять существующие ключи в `Localizable.xcstrings`
   - Использовать существующие ключи там, где возможно:
     - `Home.Activity` для "Активность"
     - `.workoutDay`, `.stretchDay`, `.restDay`, `.sickDay` для типов активности (из `DayActivityType`)
     - Другие общие ключи из основного приложения
   - Добавлять новые ключи только если они специфичны для часов и не существуют в основном приложении

4. **Статус переводов:**
   - Все новые переводы должны иметь статус `"state" : "needs_review"`
   - Переводы добавляются на русский и английский языки

### Этап 1: Настройка проекта и инфраструктуры ✅ Выполнено

#### 1.1 Настройка Watch App Target ✅ Выполнено
- [x] ✅ Минимальная версия watchOS: 10.0, App Group настроен, WatchConnectivity доступен, OSLog для логирования
- [x] ✅ Добавлены модели в Watch App target: WorkoutResult, WorkoutPreviewTraining, DayActivityType, ExerciseExecutionType, ExerciseType, DayCalculator, Constants, WorkoutData, WorkoutDataResponse, WorkoutStep, WorkoutState, WorkoutStepState
- [x] ✅ `AuthHelper` переведен на App Group с автоматической миграцией

#### 1.2 Константы и утилиты ✅ Выполнено
- [x] ✅ Enum `Constants.WatchCommand`, `WatchAppGroupHelper`, локализация displayName для часов

#### 1.3 App Group для обмена данными ✅ Выполнено
- [x] ✅ App Group настроен, `WatchAppGroupHelper` с вычисляемыми свойствами (`isAuthorized`, `startDate`, `currentDay`), данные читаются напрямую из UserDefaults без кэширования

#### 1.4 Ассеты упражнений ✅ Выполнено
- [x] ✅ `ExercisesAssets.xcassets` создан и добавлен в оба таргета

### Этап 2: Добавление Codable к моделям ✅ Выполнено
- [x] ✅ Codable добавлен к `WorkoutResult`, `WorkoutPreviewTraining`, создана структура `WorkoutData`, добавлено вычисляемое свойство `workoutData` в `DayActivity`

### Этап 3: Сервисы ✅ Выполнено
- [x] ✅ `WatchAuthService`, `WatchConnectivityService`, `WatchWorkoutService` реализованы

### Этап 4: ViewModels ✅ Выполнено
- [x] ✅ `HomeViewModel`, `WorkoutViewModel`, `WorkoutPreviewViewModel` реализованы с полной бизнес-логикой

### Этап 5: Интеграция с iPhone ✅ Выполнено
- [x] ✅ `WatchConnectivityManager` реализован, обработка всех команд WatchConnectivity, очередь запросов для actor isolation, проверка конфликтов при изменении активности

**Важные примечания:**
- ⚠️ **WCSessionDelegate для watchOS:** НЕ добавлять методы `sessionDidBecomeInactive` и `sessionDidDeactivate` (unavailable на watchOS, баг Cursor IDE)
- **Actor isolation:** Методы делегата `nonisolated` добавляют запросы в очередь через `Task { @MainActor in }`, обработка через `processPendingRequests(context:)` во вьюхе
- **Авторизация:** При авторизации часы читают статус из App Group UserDefaults, при логауте отправляется `PHONE_COMMAND_AUTH_STATUS_CHANGED`

### Этап 6: UI экранов

#### 6.1 Экран авторизации ✅ Выполнено
- [x] ✅ `AuthRequiredView` создан и интегрирован

#### 6.2 Главный экран ✅ Выполнено
- [x] ✅ `HomeView` создан с полным функционалом: отображение активности дня, выбор активности, открытие экрана превью тренировки через `.fullScreenCover`, передача зависимостей через Environment

#### 6.3 Экран выбора активности ✅ Выполнено
- [x] ✅ Созданы экраны: `DayActivitySelectionView`, `DayActivityView`, `SelectedActivityView` с полным функционалом
- [x] ✅ Реализовано отображение данных тренировки, редактирование и удаление активности, загрузка данных тренировки через `WorkoutDataResponse`
- [x] ✅ Логика выбора/изменения активности реализована с обработкой ошибок и индикаторами загрузки
- [ ] **TODO:** Добавить локализованные строки для индикаторов и ошибок (`Watch.Activity.Saving`, `Watch.Activity.Error`) в `Localizable.xcstrings`

#### 6.3.1 Экран превью тренировки ✅ Выполнено
- [x] ✅ `WorkoutPreviewView` создан с полной интеграцией с `WorkoutPreviewViewModel`
- [x] ✅ Реализованы все секции: `executionTypePicker`, список упражнений, `plannedCount`, `restTime`, кнопки управления
- [x] ✅ Toolbar кнопка редактирования реализована (открывает sheet)
- [x] ✅ `WorkoutEditView` создан с базовой структурой UI (без `customExercisesSection` для первой итерации)
- [x] ✅ Рефакторинг `WorkoutEditView` - перенос логики в ViewModel:
  - [x] ✅ Добавлены методы редактирования в `WorkoutPreviewViewModel`:
    - [x] ✅ `canRemoveExercise` computed property (проверка, что упражнений больше 1)
    - [x] ✅ `editableTrainings` computed property (фильтрация турбо-упражнений из `trainings`)
    - [x] ✅ `addStandardExercise(_ exerciseType: ExerciseType)` метод для добавления стандартного упражнения
    - [x] ✅ `removeExercise(_ exercise: WorkoutPreviewTraining)` метод для удаления упражнения (с проверкой минимального количества)
    - [x] ✅ `moveExercise(from source: IndexSet, to destination: Int)` метод для изменения порядка упражнений
    - [x] ✅ `updateTrainingCount(at index: Int, amount: Int)` метод для изменения количества повторений
    - [x] ✅ `initializeEditableExercises()` метод для инициализации редактируемого списка
  - [x] ✅ Рефакторинг `WorkoutEditView`:
    - [x] ✅ Изменена сигнатура: принимает `viewModel: WorkoutPreviewViewModel` вместо `@Binding var trainings`
    - [x] ✅ Используется локальное состояние `@State private var editableExercises` для редактирования
    - [x] ✅ При сохранении вызывается `viewModel.updateTrainings(editableExercises)`
    - [x] ✅ Реализована секция `dayExercisesSection` с отображением текущих упражнений (аналогично `WorkoutExerciseEditorScreen.dayExercisesSection`)
    - [x] ✅ Реализована секция `standardExercisesSection` с кнопками добавления стандартных упражнений (аналогично `WorkoutExerciseEditorScreen.standardExercisesSection`)
    - [x] ✅ Секция `customExercisesSection` отсутствует (не нужна для первой итерации часов)
    - [x] ✅ Используется `WorkoutExerciseEditorRowView` из основного приложения (с поддержкой watchOS через условную компиляцию) для отображения упражнений с кнопками удаления/добавления
    - [x] ✅ Добавлена поддержка перетаскивания для изменения порядка упражнений (`.onMove`)
    - [x] ✅ Обновлена интеграция в `WorkoutPreviewView`: передается `viewModel` вместо `$viewModel.trainings`
- [x] ✅ `WorkoutPreviewViewModel` реализован полностью с методами загрузки данных, обновления значений, сохранения (включая `updateTrainings(_ newTrainings: [WorkoutPreviewTraining])`)
- [x] ✅ Интеграция с View: View получает данные из ViewModel, вызывает методы ViewModel, передает зависимости в `WorkoutView`
- [x] ✅ Открытие экрана реализовано в двух сценариях: выбор активности `.workout` и редактирование существующей тренировки
- [ ] **TODO:** Редактор комментария через `TextFieldLink`:
  - [ ] Добавить `canEditComment` computed property в ViewModel
  - [ ] Реализовать `updateComment(_ newComment: String?)` метод
  - [ ] Добавить `TextFieldLink` в View с placeholder `.dayActivityCommentPlaceholder`

#### 6.4 Экран выполнения тренировки ✅ Выполнено
- [x] ✅ `WorkoutView` создан с полной интеграцией с `WorkoutViewModel`
- [x] ✅ Реализовано отображение текущего этапа тренировки (разминка, упражнение, заминка), кнопки управления, таймер отдыха
- [x] ✅ Модели `WorkoutStep`, `WorkoutState`, `WorkoutStepState` добавлены в Watch App target для идентичной логики тренировки
- [x] ✅ `WorkoutViewModel` реализован полностью: инициализация этапов, управление состоянием, завершение тренировки, уведомления об отдыхе
- **Отличия от основного приложения:** На часах отображается только текущий этап тренировки, а не вся тренировка сразу
- [x] ✅ `WorkoutRestTimerView` создан с интеграцией `CircularTimerView`, обработкой фонового режима, планированием уведомлений об отдыхе
- [x] ✅ Обработка ошибок реализована через `viewModel.error` с отображением через `.alert`
- [x] ✅ Локализованные строки добавлены для заголовков (`.workoutViewSet`, `.workoutViewCycle`)
- [ ] **TODO:** Проверить и добавить недостающие локализованные строки (`Watch.Workout.*`), добавить переводы на русский и английский

#### 6.5 Навигация и главный файл приложения ✅ Выполнено
- [x] ✅ `SotkaWatchApp.swift` настроен: навигация между экранами, проверка авторизации при запуске и активации, передача `currentDay` через Environment

### Этап 7: UI/UX оптимизация для часов

#### 7.1 Адаптация дизайна ✅ Частично выполнено
- [x] ✅ Минималистичный дизайн для маленького экрана (реализован в основных экранах)
- [x] ✅ Крупные кнопки для удобного нажатия (реализованы в основных экранах)
- [ ] Оптимизация шрифтов для читаемости
- [x] ✅ Использование системных цветов и иконок (реализовано)
- [x] ✅ Поддержка темной темы (автоматически через системные цвета)

#### 7.2 Обратная связь ✅ Частично выполнено
- [ ] Haptic feedback при действиях
- [x] ✅ Визуальная обратная связь (анимации реализованы в основных экранах)
- [x] ✅ Индикаторы загрузки и синхронизации (реализованы через `ProgressView()`)
- [x] ✅ Сообщения об ошибках (реализованы через `.alert` с `viewModel.error`)

### Этап 8: Финальное тестирование и документация

#### 8.1 Интеграционные тесты
- [ ] Тесты синхронизации между часами и iPhone (моки)
- [ ] Тесты обработки команд WatchConnectivity
- [ ] Тесты офлайн-работы (отсутствие связи с iPhone)

#### 8.2 UI-тесты (опционально)
- [ ] Тесты основных сценариев использования
- [ ] Тесты навигации между экранами
- [ ] Тесты выбора активности
- [ ] Тесты выполнения тренировки

#### 8.3 Тестирование на устройствах
- [ ] Тестирование на реальных часах (разные модели)
- [ ] Тестирование синхронизации между часами и iPhone
- [ ] Тестирование офлайн-работы
- [ ] Тестирование производительности

#### 8.4 Документация
- [ ] Обновление `feature-map.md` с информацией о часах
- [ ] Создание документации по архитектуре часов (если нужно)
- [ ] Документация API WatchConnectivity
- [ ] Инструкции по тестированию

#### 8.5 Оптимизация
- [ ] Оптимизация размера приложения
- [ ] Оптимизация производительности
- [ ] Оптимизация энергопотребления
- [ ] Оптимизация синхронизации

#### 8.6 Финальная проверка
- [ ] Проверка всех функций
- [ ] Проверка синхронизации
- [ ] Проверка офлайн-работы
- [ ] Проверка на разных моделях часов
- [ ] Проверка локализации (русский и английский)
- [ ] Проверка логирования (русский язык)
- [ ] Проверка безопасного извлечения опционалов (нет force unwrap)

## Технические детали

### Модели данных

#### Модели с Codable для передачи данных

**WorkoutResult** (обновлена для поддержки Codable):
```swift
// Models/Workout/WorkoutResult.swift
struct WorkoutResult: Equatable, Codable {
    let count: Int
    let duration: Int?
}
```

**WorkoutPreviewTraining** (обновлена для поддержки Codable):
```swift
// Models/Workout/WorkoutPreviewTraining.swift
struct WorkoutPreviewTraining: Equatable, Identifiable, Codable {
    let id: String
    let count: Int?
    let typeId: Int?
    let customTypeId: String?
    let sortOrder: Int?
    // ... остальные методы и свойства
}
```

**WorkoutData** (структура для передачи данных тренировки):
```swift
// Models/SWSharedModels/WorkoutData.swift
struct WorkoutData: Codable, Equatable {
    let day: Int
    let executionType: Int  // ExerciseExecutionType.rawValue
    let trainings: [WorkoutPreviewTraining]
    let plannedCount: Int?
    
    // Вычисляемое свойство для преобразования executionType в enum
    var exerciseExecutionType: ExerciseExecutionType? {
        ExerciseExecutionType(rawValue: executionType)
    }
}
```

**WorkoutDataResponse** (структура для передачи полных данных тренировки с iPhone на Apple Watch):
```swift
// Models/SWSharedModels/WorkoutDataResponse.swift
struct WorkoutDataResponse: Codable, Equatable {
    let workoutData: WorkoutData
    let executionCount: Int?  // Фактическое количество выполнений из DayActivity.count
    let comment: String?      // Комментарий к тренировке из DayActivity.comment
}
```

**Примечание:**
- Простые структуры (`WorkoutResult`, `WorkoutPreviewTraining`) получают Codable для прямой передачи через WatchConnectivity
- Enum'ы (`DayActivityType`, `ExerciseExecutionType`) передаются через rawValue (Int)
- `WorkoutData` - структура для передачи данных тренировки, размещается в общих моделях (`Models/SWSharedModels/`)
- `WorkoutDataResponse` - структура для передачи полных данных тренировки с iPhone на Apple Watch, включает `WorkoutData`, `executionCount`, `comment`
- `ExerciseType` добавлен в Watch App target для использования локализованных названий упражнений и иконок на экране тренировки
- Ассеты упражнений находятся в отдельном `ExercisesAssets.xcassets`, доступном обоим таргетам, что позволяет использовать иконки упражнений без дублирования
- Модели с `@Model` (SwiftData) не используются напрямую на часах, только для преобразования в простые структуры

### Команды WatchConnectivity

```swift
extension Constants {
    /// Команды для обмена данными между часами и iPhone через WatchConnectivity
    enum WatchCommand: String {
        // От часов к iPhone
        case setActivity = "WATCH_COMMAND_SET_ACTIVITY"
        case saveWorkout = "WATCH_COMMAND_SAVE_WORKOUT"
        case getCurrentActivity = "WATCH_COMMAND_GET_CURRENT_ACTIVITY"
        case getWorkoutData = "WATCH_COMMAND_GET_WORKOUT_DATA"
        case deleteActivity = "WATCH_COMMAND_DELETE_ACTIVITY"
        
        // От iPhone к часам
        case currentActivity = "PHONE_COMMAND_CURRENT_ACTIVITY"
        case sendWorkoutData = "PHONE_COMMAND_SEND_WORKOUT_DATA"
        case authStatusChanged = "PHONE_COMMAND_AUTH_STATUS_CHANGED"
    }
}
```

**Примечание:** Enum `Constants.WatchCommand` находится в файле `SwiftUI-SotkaApp/Models/SWSharedModels/Constants.swift` и доступен обоим таргетам (основному приложению и Watch App).

### Формат сообщений WatchConnectivity

**Установка активности:**
```json
{
    "command": "WATCH_COMMAND_SET_ACTIVITY",
    "day": 42,
    "activityType": 0
}
```

**Сохранение тренировки:**
```json
{
    "command": "WATCH_COMMAND_SAVE_WORKOUT",
    "day": 42,
    "result": {
        "count": 4,
        "duration": 1800
    },
    "executionType": 0,
    "trainingType": 1
}
```
*Примечание: `result` содержит сериализованный `WorkoutResult` (Codable) в JSON формате*

**Удаление активности:**
```json
{
    "command": "WATCH_COMMAND_DELETE_ACTIVITY",
    "day": 42
}
```

**Примечание:** Команды проверки авторизации и получения/обновления текущего дня не нужны (см. раздел 1.3). Команды для получения данных пользователя также не нужны - часы не отображают данные пользователя (имя, email и т.д.).

**Ответ с текущей активностью дня:**
```json
{
    "command": "PHONE_COMMAND_CURRENT_ACTIVITY",
    "day": 42,
    "activityType": 0,
    "count": null,
    "duration": null
}
```

**Уведомление об изменении статуса авторизации:**
```json
{
    "command": "PHONE_COMMAND_AUTH_STATUS_CHANGED",
    "isAuthorized": true
}
```
*Примечание: Команда отправляется при успешной авторизации (`isAuthorized: true`) или при логауте (`isAuthorized: false`). Часы также проверяют статус авторизации при активации приложения через `task(id: scenePhase)` для обеспечения актуальности данных даже при отсутствии связи.*

## Риски и митигация

### Риск 1: Ограничения WatchConnectivity
- **Проблема:** WatchConnectivity может быть недоступен или нестабилен
- **Митигация:** Реализовать очередь несинхронизированных действий, повторные попытки синхронизации

### Риск 2: Различия в данных между часами и iPhone
- **Проблема:** Данные на часах могут отличаться от данных на iPhone
- **Митигация:** iPhone является основным источником истины, часы получают обновления от iPhone

### Риск 3: Производительность на часах
- **Проблема:** Ограниченные ресурсы часов могут влиять на производительность
- **Митигация:** Оптимизация кода, минимальное использование ресурсов, кэширование данных

### Риск 4: Сложность синхронизации
- **Проблема:** Синхронизация между часами и iPhone может быть сложной
- **Митигация:** Простая архитектура синхронизации, четкие команды, обработка ошибок

### Риск 5: Работа часов без авторизации
- **Проблема:** Часы могут попытаться работать без авторизации на iPhone
- **Митигация:** Обязательная проверка авторизации при запуске, блокировка функционала без авторизации, экран с сообщением о необходимости авторизации

### Риск 6: Отсутствие связи с iPhone
- **Проблема:** Часы могут быть недоступны для связи с iPhone
- **Митигация:** Показ сообщения об ошибке, блокировка действий, требующих сохранения данных. Минимальное кэширование только для отображения текущего дня (опционально)

## Приоритеты разработки

### Высокий приоритет (MVP)
1. **Добавление Codable к простым моделям** для передачи данных
2. **Проверка авторизации и блокировка функционала без авторизации**
3. **Запрос данных с iPhone** (текущий день, активность, данные тренировки)
4. **Отправка действий в iPhone** для сохранения в SwiftData (с использованием Codable моделей)
5. Главный экран с отображением текущего дня (только для авторизованных)
6. Выбор типа активности (сохранение через iPhone)
7. Обработка отсутствия связи с iPhone

### Средний приоритет
1. Выполнение тренировки
2. Сохранение результата тренировки
3. Полная синхронизация данных

### Низкий приоритет (будущие улучшения)
1. Расширенная статистика тренировок
2. Интеграция с HealthKit
3. Уведомления о тренировках
4. Циферблаты с данными программы

## Отличия от реализации в старом приложении (SOTKA-OBJc)

Этот раздел описывает ключевые отличия планируемой реализации в новом приложении от реализации в старом приложении SOTKA-OBJc.

### Архитектура хранения данных

**Старое приложение (SOTKA-OBJc):**
- Часы используют **CoreData** для локального хранения данных
- Модели: `WatchDbDay`, `WatchDbTraining`, `WatchDbCustomExercise`, `WatchDbSettings`
- Данные сохраняются локально на часах с флагом `synched` для отслеживания синхронизации
- Двусторонняя синхронизация: часы работают независимо, синхронизируются периодически
- Очередь несинхронизированных данных на часах

**Новое приложение:**
- Часы **не хранят данные локально** (статус авторизации читается напрямую из UserDefaults App Group, без отдельного кэширования)
- Все данные запрашиваются с iPhone в реальном времени
- iPhone является **единственным хранилищем данных** (SwiftData)
- Часы работают как **клиент iPhone приложения**
- Нет очереди синхронизации - все действия передаются немедленно

### Формат передачи данных

**Старое приложение:**
- Используются **JSON строки** (NSString) в Dictionary
- Команды передаются как **числовые константы** (enum WATCH_COMMANDS: 0, 1, 2...)
- Данные сериализуются в JSON строку через `toJSONString()`
- Пример: `@{@"command": @"0", @"days": jsonString}`

**Новое приложение:**
- Используются **модели с Codable** для прямой передачи данных (без DTO)
- Команды передаются как **строковые enum** (WatchCommand: "WATCH_COMMAND_GET_TRAIN_LIST")
- Данные сериализуются через JSONEncoder/JSONDecoder
- Пример: `{"command": "WATCH_COMMAND_SAVE_WORKOUT", "result": {...}}`

### Команды WatchConnectivity

**Старое приложение:**
- `WATCH_COMMAND_GET_TRAIN_LIST` (0) - запрос данных тренировки
- `WATCH_COMMAND_SAVE_TRAININGS` (1) - сохранение тренировок (массив дней)
- `PHONE_COMMAND_UPDATE_CURRENT_DAY` (2) - обновление текущего дня
- `PHONE_SYNC_REQUEST` (3) - запрос синхронизации
- `PHONE_COMMAND_GET_UNSYNCED_TRAININGS` (4) - запрос несинхронизированных тренировок

**Новое приложение:**
- Расширенный набор команд с явными названиями
- Более детальное разделение команд (отдельно для активности и тренировки)
- **Примечание:** Команды проверки авторизации и выхода из аккаунта не нужны, так как статус авторизации читается напрямую из App Group UserDefaults (см. раздел 1.3). Команды для получения данных пользователя также не нужны - часы не отображают данные пользователя.

### Авторизация

**Старое приложение:**
- Не видно явной проверки авторизации при запуске часов
- Часы могут работать без явной проверки статуса авторизации

**Новое приложение:**
- **Обязательная проверка авторизации** при запуске приложения на часах
- Блокировка функционала без авторизации
- Экран `AuthRequiredView` для неавторизованных пользователей
- Статус авторизации читается напрямую из App Group UserDefaults (см. раздел 1.3)

### Обработка данных тренировки

**Старое приложение:**
- Данные тренировки передаются как `WatchObject` (JSON строка)
- Сохранение тренировок происходит пакетами (массив дней)
- Локальное сохранение на часах перед синхронизацией

**Новое приложение:**
- Данные тренировки передаются через модели с Codable (`WorkoutData`, `WorkoutResult`)
- Сохранение происходит по одной активности/тренировке
- Немедленная передача в iPhone без локального сохранения

### Синхронизация

**Старое приложение:**
- Двусторонняя синхронизация с флагом `synched`
- Часы могут работать офлайн с последующей синхронизацией
- Очередь несинхронизированных данных на часах
- iPhone может запрашивать несинхронизированные данные с часов

**Новое приложение:**
- Односторонняя передача данных: часы → iPhone (для сохранения)
- Часы запрашивают данные с iPhone в реальном времени
- Нет очереди синхронизации - все действия передаются немедленно
- При отсутствии связи показывается ошибка, действия не выполняются

### Технологии

**Старое приложение:**
- Objective-C
- CoreData на часах
- UIKit для часов (WatchKit)
- JSON строки для передачи данных

**Новое приложение:**
- Swift 6.0
- SwiftData на iPhone (не используется на часах)
- SwiftUI для часов
- Codable модели для прямой передачи данных (без DTO)

### Преимущества нового подхода

1. **Упрощенная архитектура:**
   - Нет дублирования данных между часами и iPhone
   - Нет конфликтов данных
   - Проще поддержка и отладка

2. **Актуальность данных:**
   - Данные всегда актуальны (запрашиваются в реальном времени)
   - Нет рассинхронизации между устройствами

3. **Безопасность:**
   - Обязательная проверка авторизации
   - Данные хранятся только на iPhone

4. **Современные технологии:**
   - SwiftUI вместо WatchKit
   - SwiftData вместо CoreData
   - Codable модели вместо ручной сериализации JSON и DTO

### Недостатки нового подхода

1. **Зависимость от связи:**
   - Часы не могут работать полностью офлайн
   - Требуется постоянная связь с iPhone для работы

2. **Производительность:**
   - Каждый запрос требует связи с iPhone
   - Может быть медленнее при плохой связи

3. **Ограничения:**
   - Меньше автономности часов
   - Зависимость от доступности iPhone

## Заключение

Этот план описывает детальную разработку приложения для Apple Watch с сокращенным функционалом по сравнению с основным iOS-приложением. Основные компоненты:

1. **Авторизация** - проверка статуса авторизации и блокировка функционала без авторизации
2. **Локальное вычисление текущего дня** - вычисляется локально на часах из `startDate` с помощью `DayCalculator` (см. раздел 1.3)
3. **Запрос данных с iPhone** - данные активности и тренировок запрашиваются с iPhone в реальном времени
4. **Сохранение через iPhone** - все действия передаются в iPhone для сохранения в SwiftData
5. **Главный экран** - отображение текущего дня и активности (только для авторизованных)
6. **Выбор активности** - выбор типа активности из 4 вариантов (сохранение через iPhone)
7. **Выполнение тренировки** - упрощенный интерфейс для выполнения тренировки (данные с iPhone, сохранение через iPhone)

### Ключевые принципы

- **iPhone приложение - единственное хранилище данных**: все данные хранятся только на iPhone в SwiftData, часы не хранят данные локально
- **Часы как клиент**: часы запрашивают данные с iPhone и отправляют действия для сохранения, не хранят данные самостоятельно
- **Обязательная авторизация**: приложение для часов работает только после успешной авторизации в iPhone приложении
- **Чтение статуса авторизации и `startDate`**: напрямую из App Group UserDefaults (см. раздел 1.3)
- **Текущий день**: вычисляется локально на часах из `startDate` с помощью `DayCalculator`
- **Безопасность**: при выходе из аккаунта статус обновляется в App Group UserDefaults
- **Обработка офлайн-режима**: при отсутствии связи с iPhone показывать сообщение об ошибке, не выполнять действия, требующие сохранения

Приложение для часов работает как клиент iPhone приложения, запрашивая данные и отправляя действия для сохранения. Все данные хранятся только на iPhone в SwiftData, что упрощает архитектуру и исключает конфликты данных.

