# План разработки приложения для Apple Watch

## Обзор

Этот документ описывает детальный план разработки приложения для Apple Watch с сокращенным функционалом по сравнению с основным iOS-приложением. Приложение для часов будет поддерживать выбор типа активности на день и выполнение тренировок с синхронизацией данных между часами и iPhone.

## Цели и ограничения

### Функционал для часов
- Выбор типа активности на сегодняшний день из 4 вариантов (`DayActivityType`):
  - `workout` - тренировка
  - `stretch` - растяжка
  - `rest` - отдых
  - `sick` - болезнь
- Выполнение тренировки (если выбран тип `workout`):
  - Упрощенный интерфейс выполнения тренировки
  - Сохранение результата тренировки
- Синхронизация данных между часами и iPhone:
  - Двусторонняя синхронизация через WatchConnectivity
  - Синхронизация выбранных активностей
  - Синхронизация результатов тренировок
  - Синхронизация текущего дня программы

### Ограничения
- Минимальный UI для часов (ограниченный размер экрана)
- Упрощенная логика тренировок (без сложных настроек)
- **Часы не хранят данные локально** - все данные запрашиваются с iPhone и сохраняются через iPhone в SwiftData
- **Статус авторизации и номер текущего дня** передаются через WatchConnectivity (см. раздел 1.3)
- **Текущий день** получается только из WatchConnectivity (готовый номер дня), при отсутствии связи показывается `AuthRequiredView`
- **iPhone приложение является единственным хранилищем данных** (SwiftData)
- **Приложение для часов работает только после успешной авторизации в iPhone приложении**

## Архитектура

### Структура проекта

```
SotkaWatch Watch App/
├── Models/
│   ├── AuthState.swift                 # Модель состояния авторизации для Watch App ✅
│   └── WorkoutPreviewTraining+ActivityRowData.swift # Расширение для отображения упражнений ✅
├── Services/
│   ├── WatchAuthService.swift          # Сервис авторизации для Watch App ✅
│   ├── WatchAuthServiceProtocol.swift  # Протокол сервиса авторизации ✅
│   ├── WatchConnectivityService.swift  # Сервис связи с iPhone через WatchConnectivity ✅
│   ├── WatchConnectivityServiceProtocol.swift # Протокол сервиса связи ✅
│   ├── WatchWorkoutService.swift       # Сервис тренировок для Watch App ✅
│   └── WCSessionProtocol.swift         # Протокол для WCSession (для тестирования) ✅
├── ViewModels/
│   ├── HomeViewModel.swift              # ViewModel для главного экрана ✅
│   ├── WorkoutViewModel.swift          # ViewModel для экрана тренировки ✅
│   └── WorkoutPreviewViewModel.swift   # ViewModel для экрана превью тренировки ✅
├── Views/
│   ├── AuthRequiredView.swift          # Экран для неавторизованных пользователей ✅
│   ├── HomeView.swift                  # Главный экран часов ✅
│   ├── DayActivityView.swift           # Экран активности дня (выбор/отображение) ✅
│   ├── DayActivitySelectionView.swift  # Выбор типа активности ✅
│   ├── SelectedActivityView.swift      # Отображение выбранной активности ✅
│   ├── WatchDayActivityTrainingView.swift # Компонент отображения данных тренировки ✅
│   ├── WatchDayActivityCommentView.swift  # Компонент отображения комментария ✅
│   ├── WorkoutPreviewView.swift        # Экран превью тренировки ✅
│   ├── WorkoutEditView.swift           # Экран редактирования упражнений в тренировке ✅
│   ├── WorkoutStepperView.swift        # Компонент для изменения значений (stepper) ✅
│   ├── WorkoutView.swift               # Экран выполнения тренировки ✅
│   └── WorkoutRestTimerView.swift      # Таймер отдыха между кругами/подходами ✅

Примечание: 
- Модели данных переиспользуются из основного приложения, локальные модели для Watch App размещаются в `Models/`
- Модели для этапов тренировки (WorkoutStep, WorkoutState, WorkoutStepState) добавлены в Watch App target
- Простые структуры получают Codable для передачи через WatchConnectivity, модели с `@Model` (SwiftData) не используются на часах
- Ассеты упражнений в отдельном `ExercisesAssets.xcassets`, доступном обоим таргетам
```

### Технологии

- **SwiftUI** - для UI (watchOS поддерживает SwiftUI)
- **WatchConnectivity** - для связи с iPhone
- **OSLog** - для логирования

**Важно:** 
- Часы не используют SwiftData, все данные запрашиваются с iPhone в реальном времени
- Модели переиспользуются из основного приложения, простые структуры получают Codable для передачи через WatchConnectivity
- UIKit API недоступны на watchOS: методы, использующие `UIImpactFeedbackGenerator`, `UIViewControllerRepresentable` и другие UIKit компоненты, должны быть исключены из компиляции для watchOS через `#if !os(watchOS)` или помечены `@available(watchOS, unavailable)`
- Платформо-специфичные SwiftUI компоненты (например, `TextFieldLink` для watchOS) должны быть обернуты в условную компиляцию `#if os(watchOS)`

### Обмен данными между часами и iPhone

#### WatchConnectivity Service

**Архитектура связи:**
- iPhone - единственное хранилище данных (SwiftData)
- Часы не хранят данные локально - все данные получаются только через WatchConnectivity в реальном времени
- Все действия с часов передаются в iPhone через WatchConnectivity (`sendMessage`)
- Статус авторизации и номер текущего дня передаются через WatchConnectivity

**Команды синхронизации:** (см. раздел "Команды WatchConnectivity" ниже)

**Механизмы передачи данных:**
- `sendMessage` - для немедленной передачи данных, требует активного соединения
- `updateApplicationContext` - для передачи данных, работает даже когда приложение на часах закрыто (без поля "command")

**Формат данных:**
- JSON для передачи сложных структур
- Простые типы (Int, String, Bool) для простых команд

#### Разрешение конфликтов при одновременном изменении активности

**Проблема:**
При одновременном изменении активности на один и тот же день с разных устройств (часы и iPhone) могут возникать конфликты. Например:
- На iPhone начали тренировку (создана активность `.workout`), но не закончили и свернули приложение
- На часах выбрали активность "отдых" для того же дня
- Без специальной обработки активность будет перезаписана на "отдых", что приведет к потере данных о тренировке

**Стратегия разрешения конфликтов:**

1. **Приоритет незавершенных тренировок:**
   - Если на день уже существует активность типа `.workout` (тренировка), изменение на другой тип активности (`.rest`, `.stretch`, `.sick`) должно быть запрещено или требовать подтверждения
   - Это предотвращает случайную потерю данных о начатой тренировке
   - Проверка выполняется на iPhone при обработке команды `WATCH_COMMAND_SET_ACTIVITY` от часов

2. **Last Write Wins (LWW) для других случаев:**
   - Для активностей типа `.rest`, `.stretch`, `.sick` применяется стратегия LWW на основе `modifyDate`
   - Последнее изменение побеждает (обновляется `modifyDate` при каждом изменении)
   - Это соответствует существующей логике разрешения конфликтов при синхронизации с сервером

3. **Проверка перед изменением:**
   - При получении команды `WATCH_COMMAND_SET_ACTIVITY` на iPhone:
     - Проверить существующую активность для указанного дня
     - Если активность существует и имеет тип `.workout`:
       - Отклонить изменение (вернуть ошибку на часы)
       - Или запросить подтверждение у пользователя (если изменение запрошено с iPhone)
     - Если активность не существует или имеет другой тип - выполнить изменение

4. **Уведомление пользователя:**
   - При попытке изменить активность на часах, если на iPhone есть незавершенная тренировка:
     - Показать сообщение об ошибке на часах: "Нельзя изменить активность: на телефоне начата тренировка"
     - Предложить завершить тренировку на телефоне или отменить её перед изменением активности

5. **Специальный случай - завершенные тренировки:**
   - Если тренировка завершена (есть `count` и `duration`), изменение на другой тип активности разрешено
   - Это позволяет пользователю изменить активность после завершения тренировки

**Реализация:**
- Логика проверки конфликтов реализуется в `StatusManager` на iPhone при обработке команды `WATCH_COMMAND_SET_ACTIVITY`
- Используется `DailyActivitiesService` для проверки существующей активности
- При обнаружении конфликта возвращается ошибка на часы через WatchConnectivity (replyHandler)
- Часы обрабатывают ошибку и показывают соответствующее сообщение пользователю

**Примечание:**
- Эта стратегия применяется только для конфликтов между часами и iPhone
- Конфликты при синхронизации с сервером разрешаются по существующей логике LWW в `DailyActivitiesService.downloadServerActivities()`

## Детальный план реализации

**Важно:** План следует принципам TDD (Test-Driven Development). Сначала пишутся тесты, затем реализация. UI реализуется в последнюю очередь.

### Принципы локализации для Watch App

1. **Использование общего файла локализации:**
   - Файл `SupportingFiles/Localizable.xcstrings` уже добавлен в Watch App target
   - Все строки для часов добавляются в этот же файл с префиксом `Watch.*`
   - Использование общего файла упрощает поддержку и позволяет переиспользовать общие строки

2. **Локализация displayName для часов:** ✅

3. **Избежание дублей ключей:**
   - Перед добавлением новых ключей обязательно проверять существующие ключи в `Localizable.xcstrings`
   - Использовать существующие ключи там, где возможно (`Home.Activity`, `.workoutDay`, `.stretchDay`, `.restDay`, `.sickDay` и др.)
   - Добавлять новые ключи только если они специфичны для часов и не существуют в основном приложении

4. **Статус переводов:**
   - Все новые переводы должны иметь статус `"state" : "needs_review"`
   - Переводы добавляются на русский и английский языки

### Этап 1-6: Основная реализация ✅
Настройка проекта, Codable модели, сервисы, ViewModels, интеграция с iPhone, UI экраны. ⚠️ WCSessionDelegate для watchOS: НЕ добавлять методы `sessionDidBecomeInactive` и `sessionDidDeactivate` (unavailable на watchOS).

**Локализация:** ✅ Базовые строки (`Watch.AuthRequired.*`) добавлены, используются общие строки из основного приложения.

### Этап 7: UI/UX оптимизация для часов

#### 7.1 Адаптация дизайна ✅ Частично выполнено
- [ ] Оптимизация шрифтов для читаемости

#### 7.2 Обратная связь ✅ Выполнено

### Этап 8: Финальное тестирование и документация

#### 8.1-8.2 Тестирование ✅ Выполнено

#### 8.3 UI-тесты (опционально) ✅ Частично выполнено
- ✅ Тест `testMakeScreenshots()` создан с вызовами `snapshot()` для всех экранов
- ⏳ Требуется тестирование генерации скриншотов через fastlane (Шаг 6)

#### 8.4 Тестирование на устройствах ⏳ Частично выполнено
- ✅ Тестирование на симуляторах - выполнено, все функции работают
- ⏳ Тестирование на реальных часах (разные модели) - требуется (Этап 8.4.3)
- ⏳ Тестирование синхронизации между часами и iPhone - требуется (Этап 8.4.3)
- ⏳ Тестирование обработки ошибок при отсутствии связи с iPhone - требуется (Этап 8.4.3)
- ⏳ Тестирование производительности - требуется (Этап 8.4.3)

##### 8.4.1 Анализ логов синхронизации ✅ Выполнено

##### 8.4.2 Исправление багов, найденных при ручном тестировании ✅ Выполнено

##### 8.4.3 Тестирование на реальных устройствах ⏳ **В ОЖИДАНИИ**
- [ ] Протестировать на реальных устройствах после исправлений
- [ ] Проверить устранение дублирования вызовов
- [ ] Проверить оптимизацию логирования
- [ ] Убедиться, что `currentDay` передается в Application Context после загрузки данных

**Приоритет:** СРЕДНИЙ - критическая проблема решена, требуется валидация на реальных устройствах.

#### 8.5 Документация
- [ ] Обновление `feature-map.md` с информацией о часах
- [ ] Создание документации по архитектуре часов (если нужно)
- [ ] Документация API WatchConnectivity
- [ ] Инструкции по тестированию

#### 8.6 Оптимизация

##### 8.6.1 Исправление лишних событий синхронизации между iPhone и часами ✅
Предотвращено дублирование вызовов, оптимизировано логирование, реализована дедупликация. ⏳ Требуется тестирование на реальных устройствах (Этап 8.4.3).

##### 8.6.2 Рефакторинг метода `loadData()` в `HomeViewModel` ✅
Метод разбит на специализированные методы. Все тесты проходят.

#### 8.7 Финальная проверка ⚠️ Частично выполнено

##### 8.7.1 Проверка синхронизации ✅
- ✅ Компиляция для watchOS, безопасное извлечение опционалов, логирование на русском, локализация
- ⏳ Проверка функций, обработки ошибок и на разных моделях часов - требуется тестирование на реальных устройствах (Этап 8.4.3)

#### 8.8 Интеграционные тесты для проверки полного сценария запуска ✅ Выполнено

#### 8.9 Проверка вызовов из UI компонентов ✅ Выполнено

#### 8.10 Финальная проверка и рефакторинг ⚠️ **ЧАСТИЧНО ВЫПОЛНЕНО**
✅ Все тесты проходят, форматирование проверено, основные проблемы исправлены. ⏳ Требуется тестирование на реальных устройствах.
- [ ] Оптимизация размера приложения
- [ ] Оптимизация производительности
- [ ] Оптимизация энергопотребления

### Этап 9: Известные баги и проблемы

#### 9.1 Проблема с синхронизацией currentDay при запуске приложения на часах ⚠️ **АКТИВНЫЙ БАГ**

**Описание проблемы:**
При запуске приложения на часах иногда отображается неправильный день (например, "день 1" вместо реального дня программы). Проблема проявляется, когда:
- Приложение на часах запускается до того, как iPhone полностью загрузил данные (`didLoadInitialData = false`)
- WCSession активируется на часах и получает Application Context только с `isAuthorized`, но без `currentDay`
- После загрузки данных на iPhone, обновление `currentDay` может не дойти до часов, если они уже получили Application Context без этого поля

**Логи проблемы:**
```
Application context data is nil
WCSession активирована с состоянием: 2
Получен Application Context при активации: ["isAuthorized": 1]
Обновление статуса авторизации из Application Context: true
Обновление статуса авторизации: true
Application context data is nil
Проверка статуса авторизации: true
Проверка статуса авторизации: true
Текущий день еще не получен от iPhone, ожидаем команду PHONE_COMMAND_CURRENT_DAY.
```

**Анализ проблемы:**

1. **Race condition при активации WCSession:**
   - При активации WCSession на iPhone вызывается `sendApplicationContextOnActivation()`
   - Если `didLoadInitialData = false`, то Application Context отправляется только с `isAuthorized`, без `currentDay` (строки 357-370 в `StatusManager.swift`)
   - Часы получают Application Context без `currentDay` и устанавливают его в `nil`
   - После загрузки данных на iPhone вызывается `sendCurrentStatus()`, но часы могут не получить обновление, если они уже обработали Application Context

2. **Проблема с обновлением Application Context:**
   - `updateApplicationContextOnWatch()` вызывается в `sendCurrentStatus()`, но если часы уже получили Application Context без `currentDay`, они могут не обработать обновление корректно
   - Метод `handleApplicationContext()` на часах обновляет `currentDay` только если он присутствует в контексте (строка 447 в `WatchConnectivityService.swift`), но если контекст был получен без `currentDay`, то значение остается `nil`

3. **Отсутствие явного запроса currentDay:**
   - Часы ожидают команду `PHONE_COMMAND_CURRENT_DAY` (строка 271 в `HomeViewModel.swift`), но эта команда отправляется только при изменении дня, а не при запуске приложения
   - Если Application Context был получен без `currentDay`, часы не могут запросить его явно

4. **Проблема с nil Application Context:**
   - Лог "Application context data is nil" указывает на то, что иногда Application Context может быть `nil` при получении на часах
   - Это может происходить, если iPhone еще не отправил Application Context или если произошла ошибка при передаче

**Детальный анализ причин:**

1. **Последовательность событий при проблеме:**
   - iPhone запускается, WCSession активируется → вызывается `sendApplicationContextOnActivation()`
   - В этот момент `didLoadInitialData = false`, поэтому Application Context отправляется только с `isAuthorized: true`, без `currentDay`
   - Часы получают Application Context без `currentDay` и устанавливают `connectivityService.currentDay = nil`
   - iPhone продолжает загрузку данных через `getStatus()`
   - После завершения `getStatus()` вызывается `sendCurrentStatus()` с актуальным `currentDay` (строка 172)
   - `updateApplicationContextOnWatch()` вызывается и обновляет Application Context с `currentDay`
   - Но часы уже обработали Application Context без `currentDay` и могут не получить обновление, если:
     - Часы недоступны (`isReachable = false`) - тогда `sendMessage` не отправляется (строка 295)
     - Application Context обновляется, но часы могут не обработать обновление, если приложение уже запущено и обработало предыдущий контекст

2. **Проблема с обработкой Application Context на часах:**
   - Метод `handleApplicationContext()` обновляет `currentDay` только если он присутствует в контексте (строка 447 в `WatchConnectivityService.swift`)
   - Если Application Context был получен без `currentDay`, значение остается `nil`
   - При получении обновленного Application Context с `currentDay`, метод должен обновить значение, но может быть race condition

3. **Проблема с nil Application Context:**
   - Лог "Application context data is nil" может означать, что `sessionProtocol.receivedApplicationContext` пуст при проверке (строка 283 в `WatchConnectivityService.swift`)
   - Это может происходить, если iPhone еще не отправил Application Context или если произошла ошибка при передаче

4. **Отсутствие явного запроса currentDay:**
   - Часы ожидают команду `PHONE_COMMAND_CURRENT_DAY` (строка 271 в `HomeViewModel.swift`), но эта команда отправляется только при изменении дня через `sendDayDataToWatch()` (строка 128 в `SwiftUI_SotkaAppApp.swift`)
   - При запуске приложения на часах, если `currentDay` не получен, часы не могут запросить его явно

5. **Проблема с дедупликацией:**
   - Метод `hasStatusChanged()` проверяет, изменился ли статус по сравнению с `lastSentStatus` (строка 336)
   - Если Application Context был отправлен без `currentDay` (при активации), а затем `sendCurrentStatus()` вызывается с `currentDay`, то `hasStatusChanged()` вернет `true` и обновление должно быть отправлено
   - Но если часы уже обработали Application Context без `currentDay`, они могут не обработать обновление корректно

**Возможные решения:**

1. **Отправка currentDay после загрузки данных:**
   - ✅ Уже реализовано: `sendCurrentStatus()` вызывается в `getStatus()` после завершения синхронизации (строка 172)
   - ⚠️ Проблема: если WCSession активируется до завершения `getStatus()`, Application Context отправляется без `currentDay`
   - **Решение:** После установки `didLoadInitialData = true` всегда вызывать `sendCurrentStatus()` повторно, чтобы гарантировать отправку `currentDay`

2. **Явный запрос currentDay с часов:**
   - Добавить механизм явного запроса `currentDay` с часов, если он не был получен в Application Context
   - Использовать существующую команду или добавить новую команду `WATCH_COMMAND_GET_CURRENT_DAY`
   - При запуске приложения на часах, если `currentDay = nil` и пользователь авторизован, запросить `currentDay` с iPhone

3. **Повторная отправка Application Context:**
   - ✅ Уже реализовано: `updateApplicationContextOnWatch()` вызывается всегда, даже если часы недоступны (строка 292)
   - ⚠️ Проблема: Application Context может быть обновлен, но часы могут не обработать обновление, если уже обработали предыдущий контекст
   - **Решение:** Убедиться, что `handleApplicationContext()` на часах всегда обрабатывает обновления, даже если `currentDay` был `nil` ранее

4. **Обработка nil Application Context:**
   - Добавить проверку на пустой Application Context при активации WCSession на часах
   - Если Application Context пуст или не содержит `currentDay`, но пользователь авторизован, явно запросить `currentDay` с iPhone через `sendMessage`

5. **Улучшение логики обработки Application Context на часах:**
   - Если Application Context получен без `currentDay`, но пользователь авторизован, явно запросить `currentDay` с iPhone
   - Добавить таймаут для ожидания `currentDay` и повторный запрос, если он не получен в течение определенного времени
   - Улучшить логику в `handleApplicationContext()` для обработки случаев, когда `currentDay` отсутствует в контексте

6. **Гарантированная отправка currentDay после активации:**
   - После активации WCSession на iPhone, если `didLoadInitialData = false`, установить флаг для повторной отправки Application Context после загрузки данных
   - После установки `didLoadInitialData = true`, проверить флаг и отправить Application Context с `currentDay`, если он был отправлен без него ранее

**Приоритет:** ВЫСОКИЙ - проблема влияет на корректность отображения данных на часах

**Статус:** ⚠️ Требуется анализ и исправление

**Воспроизводимость:** Иногда (зависит от порядка запуска приложений на iPhone и часах)

**Связанные файлы:**
- `SwiftUI-SotkaApp/Services/StatusManager.swift` - отправка Application Context и `sendCurrentStatus()`
- `SotkaWatch Watch App/Services/WatchConnectivityService.swift` - обработка Application Context на часах
- `SotkaWatch Watch App/ViewModels/HomeViewModel.swift` - проверка `currentDay` и загрузка данных

#### 9.2 Неправильный выбор executionType по умолчанию для дней 92-98 на часах ⚠️ **АКТИВНЫЙ БАГ**

**Описание проблемы:**
На часах для дней 92-98 всегда выбирается тип выполнения "круги" (`.cycles`) вместо "турбо" (`.turbo`), который должен быть по умолчанию для этих дней. В основном приложении (iPhone) дефолтный тип выбирается корректно.

**Анализ проблемы:**

1. **В основном приложении (iPhone):**
   - В методе `updateData()` (строка 76-121 в `WorkoutPreviewViewModel.swift`) используется `WorkoutProgramCreator(from: dayActivity)` если есть DayActivity, или `WorkoutProgramCreator(day: dayNumber)` для нового дня
   - `WorkoutProgramCreator` имеет метод `defaultExecutionType(for: day)` который возвращает `.turbo` для дней 92-98 (строка 280-284 в `WorkoutProgramCreator.swift`)
   - В инициализаторе `WorkoutProgramCreator(day: Int, executionType: ExerciseExecutionType? = nil)` используется `executionType ?? Self.defaultExecutionType(for: day)`, что правильно устанавливает дефолтный тип
   - Затем `selectedExecutionType = creator.executionType` (строка 107) устанавливает правильный тип

2. **На часах:**
   - В методе `updateData()` (строка 142-164 в `WorkoutPreviewViewModel.swift` для часов) используется `selectedExecutionType = workoutData.exerciseExecutionType` (строка 145)
   - Проблема: `workoutData.exerciseExecutionType` может быть `nil` или неправильным значением
   - В `DayActivity.workoutData` (строка 267-272 в `DayActivity.swift`) используется `executeTypeRaw ?? ExerciseExecutionType.cycles.rawValue` - fallback на `.cycles` вместо дефолтного типа для дня
   - Если `executeTypeRaw == nil` для нового дня 92-98, то отправляется `.cycles` вместо `.turbo`
   - В часах при получении данных используется это значение напрямую без проверки на дефолтный тип для дня

3. **Корневая причина:**
   - В `DayActivity.workoutData` используется жестко заданный fallback на `.cycles` вместо использования `WorkoutProgramCreator.defaultExecutionType(for: day)`
   - В часах в методе `updateData()` не проверяется, нужно ли использовать дефолтный тип для дня, если `exerciseExecutionType` не установлен или равен неправильному значению

**Возможные решения:**

1. **Исправление в `DayActivity.workoutData`:**
   - Заменить `executeTypeRaw ?? ExerciseExecutionType.cycles.rawValue` на использование `WorkoutProgramCreator.defaultExecutionType(for: day)`
   - Это гарантирует, что для дней 92-98 будет отправляться правильный дефолтный тип `.turbo`

2. **Исправление в часах `updateData()`:**
   - Если `workoutData.exerciseExecutionType == nil`, использовать `WorkoutProgramCreator.defaultExecutionType(for: dayNumber)`
   - Это обеспечит правильный дефолтный тип даже если iPhone отправил неправильное значение

3. **Комбинированный подход (рекомендуется):**
   - Исправить `DayActivity.workoutData` для правильной отправки дефолтного типа
   - Добавить fallback в часах для дополнительной надежности

**План исправления с соблюдением TDD:**

**Шаг 1: Написать тесты для `DayActivity.workoutData`**
- Создать статическое свойство для дней 92-98: `static let turboDays = Array(92...98)`
- Создать статическое свойство для всех остальных дней (не 92-98) используя функциональный подход: `static let nonTurboDays = Array(1...100).filter { !(92...98).contains($0) }`
- Параметризированный тест: `workoutData` должен возвращать `.turbo` для дней 92-98, если `executeTypeRaw == nil`
  - Аргументы: `turboDays` (статическое свойство)
  - Ожидаемый результат: `.turbo`
- Параметризированный тест: `workoutData` должен возвращать `.cycles` для всех остальных дней (не 92-98), если `executeTypeRaw == nil`
  - Аргументы: `nonTurboDays` (статическое свойство)
  - Ожидаемый результат: `.cycles`
- Тест: `workoutData` должен возвращать сохраненное значение, если `executeTypeRaw != nil`
  - Проверка, что при установленном `executeTypeRaw` используется это значение, а не дефолтный тип

**Шаг 2: Написать тесты для часов `WorkoutPreviewViewModel.updateData()`**
- Использовать те же статические свойства из Шага 1 (или создать аналогичные в тестовом файле для часов)
- Параметризированный тест: `updateData()` должен устанавливать `.turbo` для дней 92-98, если `workoutData.exerciseExecutionType == nil`
  - Аргументы: `turboDays` (статическое свойство)
  - Ожидаемый результат: `selectedExecutionType == .turbo`
- Параметризированный тест: `updateData()` должен устанавливать `.cycles` для всех остальных дней (не 92-98), если `workoutData.exerciseExecutionType == nil`
  - Аргументы: `nonTurboDays` (статическое свойство)
  - Ожидаемый результат: `selectedExecutionType == .cycles`
- Тест: `updateData()` должен использовать значение из `workoutData.exerciseExecutionType`, если оно установлено
  - Проверка, что при установленном `workoutData.exerciseExecutionType` используется это значение, а не дефолтный тип

**Шаг 3: Реализовать исправление в `DayActivity.workoutData`**
- Заменить fallback на `.cycles` на использование `WorkoutProgramCreator.defaultExecutionType(for: day)`
- Запустить тесты из Шага 1 - они должны пройти

**Шаг 4: Реализовать исправление в часах `WorkoutPreviewViewModel.updateData()`**
- Добавить проверку: если `workoutData.exerciseExecutionType == nil`, использовать `WorkoutProgramCreator.defaultExecutionType(for: dayNumber)`
- Запустить тесты из Шага 2 - они должны пройти

**Шаг 5: Запустить все тесты и форматирование**
- Запустить `make format`
- Запустить `make test` для основного приложения
- Запустить `make test_watch` для часов
- Убедиться, что все тесты проходят

**Приоритет:** ВЫСОКИЙ - проблема влияет на корректность отображения и работы тренировок для дней 92-98 на часах

**Статус:** ⚠️ Требуется исправление

**Воспроизводимость:** Всегда для дней 92-98 на часах

**Связанные файлы:**
- `SwiftUI-SotkaApp/Models/Workout/DayActivity.swift` - метод `workoutData` (строка 258-273)
- `SotkaWatch Watch App/ViewModels/WorkoutPreviewViewModel.swift` - метод `updateData()` (строка 142-164)
- `SwiftUI-SotkaApp/Services/WorkoutProgramCreator.swift` - метод `defaultExecutionType(for:)` (строка 280-284)

## Технические детали

### Модели данных

#### Модели с Codable для передачи данных

**Модели с Codable:**
- `WorkoutResult` - результат тренировки (count, duration)
- `WorkoutPreviewTraining` - данные упражнения в тренировке
- `WorkoutData` - данные тренировки (day, executionType, trainings, plannedCount)
- `WorkoutDataResponse` - полные данные тренировки с iPhone (workoutData, executionCount, comment)
- `WatchStatusMessage` - структура для преобразования данных статуса в сообщение для отправки на часы (isAuthorized, currentDay, currentActivity)

**Примечание:**
- Простые структуры получают Codable для передачи через WatchConnectivity, enum'ы передаются через rawValue (Int)
- Модели размещены в общих моделях (`Models/SWSharedModels/`) или добавлены в Watch App target

### Команды WatchConnectivity

```swift
extension Constants {
    /// Команды для обмена данными между часами и iPhone через WatchConnectivity
    enum WatchCommand: String {
        // От часов к iPhone
        case setActivity = "WATCH_COMMAND_SET_ACTIVITY"
        case saveWorkout = "WATCH_COMMAND_SAVE_WORKOUT"
        case getCurrentActivity = "WATCH_COMMAND_GET_CURRENT_ACTIVITY"
        case getWorkoutData = "WATCH_COMMAND_GET_WORKOUT_DATA"
        case deleteActivity = "WATCH_COMMAND_DELETE_ACTIVITY"
        
        // От iPhone к часам
        case currentActivity = "PHONE_COMMAND_CURRENT_ACTIVITY"
        case sendWorkoutData = "PHONE_COMMAND_SEND_WORKOUT_DATA"
        case authStatus = "PHONE_COMMAND_AUTH_STATUS"
        case currentDay = "PHONE_COMMAND_CURRENT_DAY"
    }
}
```

**Примечание:** Enum `Constants.WatchCommand` находится в файле `SwiftUI-SotkaApp/Models/SWSharedModels/Constants.swift` и доступен обоим таргетам (основному приложению и Watch App).

**Важно:** Команды `authStatus` и `currentDay` используются отдельно:
- `authStatus` - передает статус авторизации, текущий день и текущую активность (используется через `sendMessage`)
- `currentDay` - передает только текущий день (используется при изменении дня на iPhone)

### Формат сообщений WatchConnectivity

**Установка активности:**
```json
{
    "command": "WATCH_COMMAND_SET_ACTIVITY",
    "day": 42,
    "activityType": 0
}
```

**Сохранение тренировки:**
```json
{
    "command": "WATCH_COMMAND_SAVE_WORKOUT",
    "day": 42,
    "result": {"count": 4, "duration": 1800},
    "executionType": 0,
    "trainings": [...],
    "comment": "Отличная тренировка!"
}
```

**Удаление активности:**
```json
{
    "command": "WATCH_COMMAND_DELETE_ACTIVITY",
    "day": 42
}
```

**Примечание:** 
- Команда `PHONE_COMMAND_AUTH_STATUS` передает статус авторизации, текущий день и текущую активность вместе (используется через `sendMessage`)
- Команда `PHONE_COMMAND_CURRENT_DAY` передает только текущий день (используется при изменении дня на iPhone)
- Команды для получения данных пользователя не нужны - часы не отображают данные пользователя

**Ответ с текущей активностью дня:**
```json
{
    "command": "PHONE_COMMAND_CURRENT_ACTIVITY",
    "day": 42,
    "activityType": 0,
    "count": null,
    "duration": null
}
```

**Уведомление об изменении статуса (через `sendMessage`):**
```json
{
    "command": "PHONE_COMMAND_AUTH_STATUS",
    "isAuthorized": true,
    "currentDay": 42,
    "currentActivity": 0
}
```
*Примечания:*
- Команда отправляется через `sendMessage` при авторизации/логауте или изменении `currentDayCalculator`
- `isAuthorized: Bool` - обязательное поле (статус авторизации)
- `currentDay: Int?` - опциональное поле, передается если `isAuthorized == true`
- `currentActivity: Int?` - опциональное поле (тип активности текущего дня, если активность выбрана)
- Часы получают данные только через WatchConnectivity, локальное хранение не используется

**Уведомление об изменении текущего дня (через `sendMessage`):**
```json
{
    "command": "PHONE_COMMAND_CURRENT_DAY",
    "currentDay": 42
}
```
*Примечания:*
- Команда отправляется через `sendMessage` при изменении текущего дня на iPhone
- `currentDay: Int` - обязательное поле

**Application Context (работает даже когда приложение закрыто):**
```json
{
    "isAuthorized": true,
    "currentDay": 42,
    "currentActivity": 0
}
```
*Примечания:*
- Application Context не содержит поле "command"
- Используется для передачи данных даже когда приложение на часах закрыто
- Формат данных аналогичен команде `PHONE_COMMAND_AUTH_STATUS`, но без поля "command"

**Важно:** ✅ Синхронизация реализована через `sendMessageToWatch` и `updateApplicationContext`

## Риски и митигация

**Решенные риски (1, 5-7):** ✅ Выполнено

**Активные риски:**
- **Риск 2:** Различия в данных - iPhone как источник истины
- **Риск 3:** Производительность - оптимизация кода, минимальное использование ресурсов
- **Риск 4:** Сложность синхронизации - простая архитектура, четкие команды

## Приоритеты разработки

**Высокий и средний приоритет:** ✅ Выполнено.

### Низкий приоритет (будущие улучшения)
1. Расширенная статистика тренировок
2. Интеграция с HealthKit
3. Уведомления о тренировках
4. Циферблаты с данными программы

## Отличия от реализации в старом приложении (SOTKA-OBJc)

Этот раздел описывает ключевые отличия планируемой реализации в новом приложении от реализации в старом приложении SOTKA-OBJc.

### Архитектура хранения данных

**Старое приложение (SOTKA-OBJc):**
- Часы используют **CoreData** для локального хранения данных
- Модели: `WatchDbDay`, `WatchDbTraining`, `WatchDbCustomExercise`, `WatchDbSettings`
- Данные сохраняются локально на часах с флагом `synched` для отслеживания синхронизации
- Двусторонняя синхронизация: часы работают независимо, синхронизируются периодически
- Очередь несинхронизированных данных на часах

**Новое приложение (текущее состояние):**
- Часы не хранят данные локально - все данные получаются только через WatchConnectivity в реальном времени
- iPhone - единственное хранилище данных (SwiftData), часы работают как клиент
- Синхронизация только через WatchConnectivity (`sendMessage`), при отсутствии связи показывается `AuthRequiredView`

### Формат передачи данных

**Старое приложение:**
- Используются **JSON строки** (NSString) в Dictionary
- Команды передаются как **числовые константы** (enum WATCH_COMMANDS: 0, 1, 2...)
- Данные сериализуются в JSON строку через `toJSONString()`
- Пример: `@{@"command": @"0", @"days": jsonString}`

**Новое приложение:**
- Используются **модели с Codable** для прямой передачи данных (без DTO)
- Команды передаются как **строковые enum** (WatchCommand: "WATCH_COMMAND_GET_TRAIN_LIST")
- Данные сериализуются через JSONEncoder/JSONDecoder
- Пример: `{"command": "WATCH_COMMAND_SAVE_WORKOUT", "result": {...}}`

### Команды WatchConnectivity

**Старое приложение:**
- `WATCH_COMMAND_GET_TRAIN_LIST` (0) - запрос данных тренировки
- `WATCH_COMMAND_SAVE_TRAININGS` (1) - сохранение тренировок (массив дней)
- `PHONE_COMMAND_UPDATE_CURRENT_DAY` (2) - обновление текущего дня
- `PHONE_SYNC_REQUEST` (3) - запрос синхронизации
- `PHONE_COMMAND_GET_UNSYNCED_TRAININGS` (4) - запрос несинхронизированных тренировок

**Новое приложение:**
- Расширенный набор команд с явными названиями, более детальное разделение команд (отдельно для активности и тренировки)
- Команды проверки авторизации не нужны - статус передается через WatchConnectivity (`sendMessage`)

### Авторизация

**Старое приложение:**
- Не видно явной проверки авторизации при запуске часов
- Часы могут работать без явной проверки статуса авторизации

**Новое приложение:**
- Обязательная проверка авторизации при запуске, блокировка функционала, экран `AuthRequiredView`
- Статус авторизации передается через WatchConnectivity

### Обработка данных тренировки

**Старое приложение:**
- Данные тренировки передаются как `WatchObject` (JSON строка)
- Сохранение тренировок происходит пакетами (массив дней)
- Локальное сохранение на часах перед синхронизацией

**Новое приложение:**
- Данные тренировки передаются через модели с Codable (`WorkoutData`, `WorkoutResult`)
- Сохранение по одной активности/тренировке, немедленная передача в iPhone без локального сохранения

### Синхронизация

**Старое приложение:**
- Двусторонняя синхронизация с флагом `synched`
- Часы могут работать офлайн с последующей синхронизацией
- Очередь несинхронизированных данных на часах
- iPhone может запрашивать несинхронизированные данные с часов

**Новое приложение:**
- Односторонняя передача данных: часы → iPhone (для сохранения)
- Часы запрашивают данные с iPhone в реальном времени, нет очереди синхронизации
- При отсутствии связи показывается ошибка, действия не выполняются

### Технологии

**Старое приложение:**
- Objective-C
- CoreData на часах
- UIKit для часов (WatchKit)
- JSON строки для передачи данных

**Новое приложение:**
- Swift 6.0
- SwiftData на iPhone (не используется на часах)
- SwiftUI для часов
- Codable модели для прямой передачи данных (без DTO)

### Интеграция с HealthKit

**Старое приложение (SOTKA-OBJc):**

**На iPhone:**
- Запрос разрешений на чтение данных: пульс (Heart Rate), дистанция (Distance Walking/Running), активные калории (Active Energy Burned), тренировки (Workout Type)
- Запрос разрешений на запись тренировок (Workout Type)
- Включение фоновой доставки данных о пульсе для мониторинга в реальном времени
- Настройка наблюдателя за изменениями пульса

**На Apple Watch:**
- Использование `HKWorkoutSession` для создания сессии тренировки и отслеживания в реальном времени
- Использование `HKLiveWorkoutBuilder` для сбора данных во время тренировки
- Сбор метрик в реальном времени:
  - Пульс (Heart Rate) - текущий, средний, минимальный, максимальный
  - Активные калории (Active Energy Burned)
  - Длительность тренировки
- Сохранение тренировки в HealthKit после завершения через `finishWorkout`
- Тип активности: `HKWorkoutActivityTypeCrossTraining`
- Отображение пульса и калорий в реальном времени на экране тренировки

**Новое приложение (текущее состояние):**
- Интеграция с HealthKit **не реализована** (в планах как будущее улучшение)
- Тренировки сохраняются только в SwiftData на iPhone
- Данные о пульсе и калориях не собираются во время тренировки

**Потенциальные применения HealthKit в новом приложении:**

1. **Автоматическое сохранение тренировок:**
   - Сохранение каждой завершенной тренировки в HealthKit
   - Тип активности: `HKWorkoutActivityTypeCrossTraining`
   - Данные: длительность, калории, пульс (если доступен)

2. **Отслеживание пульса во время тренировки на часах:**
   - Отображение пульса в реальном времени на экране тренировки
   - Средний, минимальный и максимальный пульс за тренировку
   - Сохранение этих данных вместе с результатом тренировки

3. **Подсчет калорий:**
   - Автоматический подсчет сожженных калорий во время тренировки
   - Отображение в приложении и сохранение в HealthKit

4. **Интеграция с экосистемой Apple Health:**
   - Данные доступны в приложении "Здоровье"
   - Совместимость с другими приложениями здоровья
   - Использование данных из HealthKit для анализа прогресса

5. **Улучшенная статистика и аналитика:**
   - Анализ пульса по тренировкам
   - Тренды калорий и активности
   - Сравнение показателей по дням программы

6. **Циферблаты и осложнения (Complications):**
   - Отображение прогресса программы на циферблате часов
   - Быстрый доступ к текущему дню и статистике

7. **Фоновое отслеживание:**
   - Продолжение отслеживания тренировки даже при закрытом приложении на часах
   - Автоматическое сохранение данных при завершении

**Приоритеты реализации:**
- **Высокий приоритет:** Сохранение тренировок в HealthKit (базовая интеграция), отслеживание пульса на часах во время тренировки, подсчет и сохранение калорий
- **Низкий приоритет:** Расширенная аналитика на основе данных HealthKit, циферблаты с данными программы, интеграция с другими метриками HealthKit (шаги, активность)

### Преимущества нового подхода

1. **Упрощенная архитектура:**
   - Нет дублирования данных между часами и iPhone
   - Нет конфликтов данных
   - Проще поддержка и отладка

2. **Актуальность данных:**
   - Данные всегда актуальны (запрашиваются в реальном времени)
   - Нет рассинхронизации между устройствами

3. **Безопасность:**
   - Обязательная проверка авторизации
   - Данные хранятся только на iPhone

4. **Современные технологии:**
   - SwiftUI вместо WatchKit
   - SwiftData вместо CoreData
   - Codable модели вместо ручной сериализации JSON и DTO

### Недостатки нового подхода

1. **Зависимость от связи:**
   - Часы не могут работать полностью офлайн
   - Требуется постоянная связь с iPhone для работы

2. **Производительность:**
   - Каждый запрос требует связи с iPhone
   - Может быть медленнее при плохой связи

3. **Ограничения:**
   - Меньше автономности часов
   - Зависимость от доступности iPhone

## Рефакторинг архитектуры WatchConnectivity

**Важно:** Рефакторинг выполняется с соблюдением правил TDD (Test-Driven Development) и unit-тестирования:
- **TDD цикл**: Красный (тест падает) → Зеленый (код проходит тест) → Рефакторинг
- **Итеративный процесс**: Тест → Код → `make format` → `make test` → Следующий тест
- **Технологии**: Swift Testing (`import Testing`), `@Test`, `#expect`, `#require`
- **Моки**: Использование моков для всех зависимостей (WCSession, сервисы)
- **Описания тестов**: Все тесты с описанием на русском языке в аннотации `@Test`

### Рефакторинг архитектуры WatchConnectivity ✅ Выполнено

### Риски и митигация

#### Риск 1: Проблемы с actor isolation

**Проблема:** Делегат WCSession `nonisolated`, а обработка команд требует `@MainActor`

**Митигация:**
- Использовать `Task { @MainActor in }` для перехода в MainActor
- Использовать `nonisolated(unsafe)` для безопасного доступа к данным
- Тестировать на разных сценариях

#### Риск 2: Потеря команд при быстрых запросах

**Проблема:** При быстрых запросах команды могут обрабатываться не в том порядке

**Митигация:**
- WatchConnectivity гарантирует порядок доставки сообщений
- Если нужна гарантия порядка - добавить последовательную обработку через Actor
- Тестировать сценарии с множественными запросами

#### Риск 3: Регрессии в существующем функционале

**Проблема:** При рефакторинге может сломаться существующий функционал

**Митигация:**
- Пошаговый рефакторинг с тестами на каждом шаге
- Сохранение существующих тестов до завершения рефакторинга
- Тщательное тестирование на реальных устройствах


## Автоматизация создания скриншотов с использованием fastlane

Этот раздел описывает пошаговый план настройки автоматической генерации скриншотов для Apple Watch приложения с использованием fastlane snapshot.

### Обзор

Fastlane snapshot поддерживает генерацию скриншотов для watchOS симуляторов. Процесс включает настройку UI-тестов, конфигурацию fastlane и создание скриншотов для различных устройств и языков.

### Преимущества использования fastlane

- Автоматическая генерация скриншотов для разных устройств и языков
- Интеграция с CI/CD процессами
- Поддержка локализации (скриншоты для разных языков)
- Единая конфигурация для всех устройств

### Пошаговый план реализации

#### Шаг 1: Проверка доступных Watch симуляторов ✅ Выполнено
Устройства выбраны и настроены в `Snapfile.watch`: `Apple Watch Series 11 (46mm)`, `Apple Watch Series 11 (42mm)`.

#### Шаг 2: Настройка UI-тестов для Watch приложения ✅ Выполнено
Тест `testMakeScreenshots()` создан с вызовами `snapshot()` для 5 экранов: выбор активности, тренировка, превью тренировки, настройка повторов, редактор упражнений.

#### Шаг 3: Обновление Snapfile для Watch устройств ✅ Выполнено
Создан отдельный `Snapfile.watch` с устройствами `Apple Watch Series 11 (46mm)`, `Apple Watch Series 11 (42mm)`, схемой `SotkaWatch Watch AppUITests` и локализацией `en-US`, `ru`.

#### Шаг 4: Создание отдельного lane для Watch скриншотов ✅ Выполнено
Создан lane `watch_screenshots` в `fastlane/Fastfile` с использованием отдельного `Snapfile.watch`.

#### Шаг 5: Настройка тестовых данных ✅ Выполнено
Используется мок-сессия `MockWatchSession` через launch argument `UITest` для предоставления тестовых данных всех экранов.

#### Шаг 6: Тестирование генерации скриншотов

**Цель:** Проверить, что процесс генерации скриншотов работает корректно.

**Действия:**
- [ ] Запустить команду `bundle exec fastlane watch_screenshots` (или `fastlane screenshots`)
- [ ] Проверить, что скриншоты создаются для всех указанных устройств
- [ ] Проверить, что скриншоты создаются для всех указанных языков
- [ ] Проверить качество скриншотов (читаемость текста, корректность отображения)
- [ ] Исправить проблемы, если они обнаружены

**Ожидаемый результат:**
- Скриншоты сохраняются в папку `fastlane/screenshots/`
- Структура папок: `fastlane/screenshots/[language]/[device]/[screenshot_name].png`
- Все скриншоты созданы успешно

#### Шаг 7: Интеграция в Makefile ✅ Выполнено
Команда `make watch_screenshots` добавлена в Makefile. ⏳ Требуется тестирование работы команды.

#### Шаг 8: Оптимизация процесса

**Цель:** Улучшить скорость и надежность генерации скриншотов.

**Действия:**
- [ ] Оптимизировать UI-тесты для уменьшения времени выполнения
- [ ] Настроить параллельное выполнение тестов (если возможно)
- [ ] Добавить обработку ошибок и повторные попытки
- [ ] Настроить очистку старых скриншотов перед генерацией новых

**Рекомендации:**
- Использовать `clear_previous_screenshots(true)` в Snapfile
- Настроить `number_of_retries` для обработки временных ошибок
- Использовать `stop_after_first_error(false)` для продолжения при ошибках на одном устройстве

#### Шаг 9: Документация процесса

**Цель:** Задокументировать процесс генерации скриншотов для команды.

**Действия:**
- [ ] Обновить README.md с инструкциями по генерации скриншотов
- [ ] Добавить описание процесса в документацию проекта
- [ ] Задокументировать структуру папок со скриншотами
- [ ] Описать процесс добавления новых скриншотов

### Требования и зависимости

**Необходимые инструменты:**
- Xcode с установленными Watch симуляторами
- fastlane (установлен через Bundler)
- Ruby и Bundler

**Необходимые файлы:**
- `fastlane/Fastfile` - конфигурация fastlane
- `fastlane/Snapfile` - конфигурация snapshot (или отдельный файл для Watch)
- `SotkaWatch Watch AppUITests/` - UI-тесты для Watch приложения

### Ожидаемые результаты

После выполнения всех шагов:
- Автоматическая генерация скриншотов для всех основных экранов Watch приложения
- Скриншоты для разных размеров экранов (42mm, 46mm)
- Скриншоты для разных языков (русский, английский)
- Удобная команда для запуска генерации (`make watch_screenshots` или `fastlane watch_screenshots`)

### Альтернативные подходы

Если fastlane snapshot не подходит по каким-то причинам:
- Использовать XCTest Plan в Xcode для создания скриншотов прямо в IDE
- Использовать скрипты на основе `xcrun simctl` для ручной генерации скриншотов
- Использовать сторонние инструменты для автоматизации скриншотов

### Примечания

- Процесс генерации скриншотов может занимать значительное время (особенно для нескольких устройств и языков)
- Рекомендуется запускать генерацию скриншотов в фоновом режиме или в CI/CD
- Скриншоты можно использовать для App Store Connect или для документации проекта

## Заключение

Этот план описывает разработку приложения для Apple Watch с сокращенным функционалом. Основные компоненты: авторизация, получение текущего дня, запрос данных с iPhone, сохранение через iPhone, главный экран, выбор активности, выполнение тренировки.

**Ключевые принципы:**
- iPhone - единственное хранилище данных (SwiftData), часы работают как клиент
- Обязательная авторизация, синхронизация через WatchConnectivity (`sendMessageToWatch`)
- Данные на часах получаются только через `WatchConnectivityService`

