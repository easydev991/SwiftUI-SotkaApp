# Экран прогресса (Progress)

## Реализованный функционал ✅

### Основные компоненты
- **Сетка прогресса**: отображение результатов по контрольным точкам (день 1, 49, 100)
- **Редактирование**: форма ввода результатов с валидацией
- **Синхронизация**: локальное сохранение в SwiftData + асинхронная синхронизация
- **Фотографии**: фронтальная, сзади, сбоку для каждой контрольной точки
- **Обработка изображений**: масштабирование (1280x720) и сжатие JPEG
- **UI компоненты**: `ProgressPhotoView`, `ProgressPhotoPicker`, `ProgressPhotoGrid`

### Архитектура
- **Модель**: `Progress` с прямыми полями для данных фотографий
- **Сервисы**: `ProgressService`, `ProgressSyncService`, `ImageProcessor`
- **Синхронизация**: офлайн-приоритет, LWW конфликты, `ProgressSnapshot`
- **Тестирование**: 361 unit-тест + 44 новых теста для логики удаления фотографий

### Реализованные тесты для удаления фотографий
- **ProgressPhotoDataTests.swift**: 6 тестов для логики удаления
- **PhotoTypeTests.swift**: 8 тестов для deleteRequestName
- **ProgressSnapshotTests.swift**: 12 тестов для computed properties
- **ProgressSyncServicePhotoTests.swift**: 5 тестов для синхронизации удаления
- **ProgressClientTests.swift**: 10 тестов для deletePhoto метода
- **ProgressSyncServiceMixedPhotoOperationsTests.swift**: 3 теста для смешанных операций

### Исправления
- ✅ Логика дней (день 49 вместо 50)
- ✅ Упрощена синхронизация (единый updateProgress)
- ✅ Валидация (частично заполненные данные)
- ✅ Мягкое удаление вместо физического

## Критический баг: смешанные операции с фотографиями ❌

### Описание бага

**Проблема:** При удалении одной фотографии и добавлении новой фотографии **другого типа** в том же прогрессе, синхронизация работает некорректно:
- Старая фотография удаляется с сервера ✅
- Новая фотография **НЕ загружается** на сервер ❌

**Важное уточнение:** Если удалить фотографию и добавить новую в **тот же слот** (например, удалить `photo_back` и добавить новую `photo_back`), то синхронизация работает корректно.

### Воспроизведение бага

**Сценарий:**
1. Создать прогресс с данными упражнений и одной фотографией (например, `photo_back`)
2. Удалить существующую фотографию (`photo_back`)
3. Добавить новую фотографию **другого типа** (например, `photo_front`)
4. Вызвать синхронизацию

**Ожидаемый результат:**
- `photo_back` удаляется с сервера
- `photo_front` загружается на сервер
- Обе операции выполняются успешно

**Фактический результат:**
- `photo_back` удаляется с сервера ✅
- `photo_front` **НЕ загружается** на сервер ❌
- Новое фото остается только локально

### Анализ корневой причины

**Проблема в логике `ProgressSyncService.updateProgressFromServerResponse`:**

```swift
// Текущая проблемная логика
func updateProgressFromServerResponse(_ progress: Progress, _ response: ProgressResponse) {
    // Обновляем URL фотографий только если они НЕ помечены для удаления
    if !progress.shouldDeletePhotoFront {
        progress.urlPhotoFront = response.photoFront
    }
    if !progress.shouldDeletePhotoBack {
        progress.urlPhotoBack = response.photoBack
    }
    if !progress.shouldDeletePhotoSide {
        progress.urlPhotoSide = response.photoSide
    }
}
```

**Проблема:** Когда фотография помечена для удаления (`shouldDeletePhotoX = true`), её URL **не обновляется** из ответа сервера. Это означает, что если новая фотография была добавлена, но старая еще помечена для удаления, то URL новой фотографии не будет установлен.

**Последовательность событий при баге:**
1. `progress.deletePhotoData(.back)` → `shouldDeletePhotoBack = true`
2. `progress.setPhotoData(.front, data: newData)` → `dataPhotoFront = newData`, но `shouldDeletePhotoBack` остается `true`
3. Синхронизация: `snapshot.shouldDeletePhoto = true` → возвращается `.needsPhotoDeletion`
4. `handlePhotoDeletion()` удаляет `photo_back` с сервера
5. При следующей синхронизации: `updateProgressFromServerResponse` **не обновляет** `urlPhotoFront`, потому что `shouldDeletePhotoBack` все еще `true`

### Тесты для воспроизведения бага

**Создан файл:** `ProgressSyncServiceMixedPhotoOperationsTests.swift`

**Ключевые тесты:**

1. **`testBugDeleteBackAddFrontPhoto`** - воспроизводит основной баг
   - **Сценарий:** Удаление `photo_back` и добавление `photo_front` в том же прогрессе
   - **Ожидание:** `deletePhoto` должен быть вызван 1 раз, `updateProgress` не должен быть вызван
   - **Фактический результат:** `deletePhoto` не вызывается, `updateProgress` вызывается 3 раза
   - **Статус:** ❌ Падает (подтверждает наличие бага)

2. **`testCorrectDeleteAndAddSameSlot`** - проверяет корректный сценарий
   - **Сценарий:** Удаление `photo_back` и добавление новой `photo_back` в тот же слот
   - **Ожидание:** `updateProgress` должен быть вызван 1 раз, `deletePhoto` не должен быть вызван
   - **Фактический результат:** `updateProgress` вызывается 3 раза, прогресс не синхронизируется
   - **Статус:** ❌ Падает (проблема с изоляцией тестов)

3. **`testProgressSnapshotPhotosForUploadLogic`** - проверяет логику снимков
   - **Сценарий:** Создание снимка прогресса с смешанными операциями (удаление + добавление)
   - **Ожидание:** `shouldDeletePhoto = true`, `photosForUpload` содержит только не удаленные фото
   - **Фактический результат:** Логика снимков работает корректно
   - **Статус:** ✅ Проходит

**Анализ результатов тестов:**

**Проблема с изоляцией тестов:** Тесты используют общий `ModelContext`, и данные от предыдущих тестов влияют на следующие. Это приводит к неожиданным результатам:
- `updateProgressCallCount = 3` вместо ожидаемого `1` из-за влияния других тестов
- `isSynced = false` из-за конфликтов между тестами

**Подтверждение бага:** Первый тест падает, но не так, как ожидалось:
- `deletePhotoCallCount = 0` - `deletePhoto` не был вызван
- `updateProgressCallCount = 3` - `updateProgress` был вызван 3 раза
- `shouldDeletePhoto(.back) = true` - флаг удаления не был сброшен

**Корневая причина:** Баг еще серьезнее, чем изначально предполагалось. Даже корректный сценарий (замена в том же слоте) не работает из-за проблем с изоляцией тестов и фундаментальными проблемами в логике синхронизации.

### План исправления

#### Этап 1: Исправление логики обновления URL фотографий

**Проблема:** `updateProgressFromServerResponse` не обновляет URL фотографий, если любая фотография помечена для удаления.

**Решение:** Обновлять URL фотографий независимо от флагов удаления других фотографий.

```swift
// Исправленная логика
func updateProgressFromServerResponse(_ progress: Progress, _ response: ProgressResponse) {
    // Обновляем URL фотографий независимо от флагов удаления
    progress.urlPhotoFront = response.photoFront
    progress.urlPhotoBack = response.photoBack
    progress.urlPhotoSide = response.photoSide
    
    // Обновляем lastModified из ответа сервера
    progress.updateLastModified(from: response)
    
    // Сбрасываем флаги удаления фотографий после успешной синхронизации
    progress.resetPhotoDeletionFlags()
    
    progress.isSynced = true
}
```

#### Этап 2: Добавление метода сброса флагов удаления

**Новый метод в модели Progress:**

```swift
extension Progress {
    /// Сбрасывает все флаги удаления фотографий
    func resetPhotoDeletionFlags() {
        shouldDeletePhotoFront = false
        shouldDeletePhotoBack = false
        shouldDeletePhotoSide = false
    }
}
```

#### Этап 3: Исправление логики сброса флагов

**Проблема:** Флаги удаления фотографий сбрасываются только после успешного удаления конкретной фотографии, но не после успешной синхронизации всего прогресса.

**Решение:** Сбрасывать все флаги удаления после успешной синхронизации прогресса.

#### Этап 4: Исправление изоляции тестов

**Проблема:** Тесты используют общий `ModelContext`, что приводит к взаимному влиянию между тестами.

**Решение:** Создавать отдельный `ModelContext` для каждого теста:

```swift
func testBugDeleteBackAddFrontPhoto() async throws {
    // Создаем изолированный контекст для каждого теста
    let context = ModelContext(try ModelContainer(for: Progress.self, User.self))
    // ... остальная логика теста
}
```

#### Этап 5: Обновление тестов

**Добавить тесты для:**
1. Корректного обновления URL фотографий при смешанных операциях
2. Правильного сброса флагов удаления после синхронизации
3. Интеграционных тестов полного цикла смешанных операций
4. Изолированных тестов без взаимного влияния

### Ожидаемые результаты после исправления

**Метрики успеха:**
- ✅ Удаление одной фотографии и добавление другой работает корректно
- ✅ URL новых фотографий обновляется из ответа сервера
- ✅ Флаги удаления сбрасываются после успешной синхронизации
- ✅ Все существующие тесты продолжают проходить
- ✅ Новые тесты для смешанных операций проходят

**Тестовые сценарии:**
1. **Удаление `photo_back` + добавление `photo_front`** → оба действия выполняются
2. **Удаление `photo_front` + добавление `photo_side`** → оба действия выполняются  
3. **Удаление `photo_side` + добавление `photo_back`** → оба действия выполняются
4. **Удаление и добавление в тот же слот** → продолжает работать как раньше

### Риски исправления

1. **Побочные эффекты:** Изменение логики обновления URL может повлиять на другие сценарии
2. **Совместимость:** Убедиться, что исправление не нарушает существующую функциональность
3. **Тестирование:** Требуется тщательное тестирование всех сценариев работы с фотографиями
4. **Изоляция тестов:** Проблемы с взаимным влиянием тестов могут скрывать реальные баги
5. **Фундаментальные проблемы:** Баг может быть глубже, чем изначально предполагалось

### Приоритет исправления

**Высокий** - баг влияет на основную функциональность работы с фотографиями прогресса и может привести к потере данных пользователей.
```
