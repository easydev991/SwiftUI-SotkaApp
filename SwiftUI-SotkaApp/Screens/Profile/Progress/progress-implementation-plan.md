# Экран прогресса (Progress)

## Реализованный функционал ✅

### Основные компоненты
- **Сетка прогресса**: отображение результатов по контрольным точкам (день 1, 49, 100)
- **Редактирование**: форма ввода результатов с валидацией
- **Синхронизация**: локальное сохранение в SwiftData + асинхронная синхронизация
- **Фотографии**: фронтальная, сзади, сбоку для каждой контрольной точки
- **Обработка изображений**: масштабирование (1280x720) и сжатие JPEG
- **UI компоненты**: `ProgressPhotoView`, `ProgressPhotoPicker`, `ProgressPhotoGrid`

### Архитектура
- **Модель**: `Progress` с прямыми полями для данных фотографий
- **Сервисы**: `ProgressService`, `ProgressSyncService`, `ImageProcessor`
- **Синхронизация**: офлайн-приоритет, LWW конфликты, `ProgressSnapshot`
- **Тестирование**: 361 unit-тест + 44 новых теста для логики удаления фотографий

### Реализованные тесты для удаления фотографий
- **ProgressPhotoDataTests.swift**: 6 тестов для логики удаления
- **PhotoTypeTests.swift**: 8 тестов для deleteRequestName
- **ProgressSnapshotTests.swift**: 12 тестов для computed properties
- **ProgressSyncServicePhotoTests.swift**: 5 тестов для синхронизации удаления
- **ProgressClientTests.swift**: 10 тестов для deletePhoto метода
- **ProgressSyncServiceMixedPhotoOperationsTests.swift**: 3 теста для смешанных операций

### Исправления
- ✅ Логика дней (день 49 вместо 50)
- ✅ Упрощена синхронизация (единый updateProgress)
- ✅ Валидация (частично заполненные данные)
- ✅ Мягкое удаление вместо физического

## КРИТИЧЕСКИЙ БАГ: Удаленные фотографии загружаются обратно ❌

### Описание бага (ОБНОВЛЕНО)

**Проблема:** После удаления фотографии из приложения при синхронизации эта же фотография **загружается обратно с сервера**, будто бы ее не удаляли.

**Анализ логов показывает:**
- 36 записей прогресса отправляются на сервер (все с `isSynced=false`)
- Сервер возвращает ошибки декодирования для большинства запросов
- После загрузки с сервера удаленные фотографии **восстанавливаются**

**Детальный анализ логов:**
```
Найдено 36 записей прогресса для проверки синхронизации
День 1: isSynced=false, shouldDelete=false, isEmpty=false (36 раз)
```
- **Проблема дублирования:** 36 записей для одного дня указывает на серьезную проблему с созданием дубликатов
- **Все записи несинхронизированы:** `isSynced=false` для всех записей
- **Ни одна не помечена для удаления:** `shouldDelete=false` для всех записей
- **Все содержат данные:** `isEmpty=false` для всех записей

```
Отправляем прогресс на сервер: день 1 (36 раз)
Отправляем прогресс дня 1 с фотографиями: для отправки=1 (36 раз)
```
- **Множественные запросы:** Один и тот же прогресс отправляется 36 раз
- **Фотографии для отправки:** Каждая запись содержит 1 фотографию для отправки

```
Ошибка синхронизации прогресса дня 1: Не удалось прочесть данные, так как они отсутствуют.
Ошибка синхронизации прогресса дня 1: Внутренняя ошибка сервера
```
- **Ошибки сервера:** Большинство запросов завершаются ошибками
- **Проблемы декодирования:** Сервер возвращает null вместо ожидаемых данных

```
Серверная версия новее локальной для дня 1 - обновляем локальные данные
Обновляем фотографии для прогресса дня 1 из ответа сервера
```
- **LWW конфликт:** Серверная версия считается новее локальной
- **Восстановление фотографий:** Фотографии обновляются из серверного ответа, что восстанавливает удаленные

### Корневая причина (ОБНОВЛЕНО)

**Проблема в методе `updateProgressFromServerResponse`:**
```swift
func updateProgressFromServerResponse(_ progress: Progress, _ response: ProgressResponse) async {
    // ❌ ПРОБЛЕМА: Обновляем URL фотографий БЕЗ проверки локальных флагов удаления
    progress.urlPhotoFront = response.photoFront
    progress.urlPhotoBack = response.photoBack  
    progress.urlPhotoSide = response.photoSide
    
    // ❌ ПРОБЛЕМА: Загружаем фотографии с сервера, перезаписывая локальные изменения
    await PhotoDownloadService().downloadAllPhotos(for: progress)
}
```

**Последовательность событий при баге:**
1. Пользователь удаляет фотографию → `progress.deletePhotoData(.back)` → `dataPhotoBack = DELETED_DATA`
2. Синхронизация отправляет прогресс на сервер
3. Сервер возвращает ответ с URL фотографий (включая удаленную)
4. `updateProgressFromServerResponse` **перезаписывает** локальные данные серверными
5. `PhotoDownloadService().downloadAllPhotos()` **загружает удаленную фотографию обратно**
6. Удаленная фотография восстанавливается ❌

### Воспроизведение бага (ОБНОВЛЕНО)

**Сценарий:**
1. Создать прогресс с фотографией (например, `photo_back`)
2. Удалить фотографию в приложении
3. Вызвать синхронизацию

**Ожидаемый результат:**
- Фотография удаляется с сервера
- Локально фотография остается удаленной
- При следующей синхронизации фотография не восстанавливается

**Фактический результат:**
- Фотография удаляется с сервера ✅
- При загрузке с сервера фотография **восстанавливается локально** ❌
- Удаление отменяется

### Дополнительные проблемы

**1. Проблема с множественными записями:**
- В логах видно 36 записей прогресса для дня 1
- Это указывает на проблему с дублированием записей в базе данных
- Множественные записи могут вызывать конфликты при синхронизации

**2. Проблема с PhotoDownloadService:**
```swift
// ❌ ПРОБЛЕМА: downloadAllPhotos загружает ВСЕ фотографии с сервера
await PhotoDownloadService().downloadAllPhotos(for: progress)
```
- Метод загружает все фотографии, включая те, что помечены для удаления локально
- Не учитывает локальные флаги удаления
- Перезаписывает локальные изменения серверными данными

**3. Проблема с логикой обновления URL:**
- URL фотографий обновляются из ответа сервера без учета локальных флагов удаления
- Это приводит к восстановлению удаленных фотографий

### Тесты для воспроизведения бага

**Создан файл:** `ProgressSyncServiceMixedPhotoOperationsTests.swift`

**Ключевые тесты:**

1. **`testBugDeleteBackAddFrontPhoto`** - воспроизводит основной баг
   - **Сценарий:** Удаление `photo_back` и добавление `photo_front` в том же прогрессе
   - **Ожидание:** `deletePhoto` должен быть вызван 1 раз, `updateProgress` не должен быть вызван
   - **Фактический результат:** `deletePhoto` не вызывается, `updateProgress` вызывается 3 раза
   - **Статус:** ❌ Падает (подтверждает наличие бага)

2. **`testCorrectDeleteAndAddSameSlot`** - проверяет корректный сценарий
   - **Сценарий:** Удаление `photo_back` и добавление новой `photo_back` в тот же слот
   - **Ожидание:** `updateProgress` должен быть вызван 1 раз, `deletePhoto` не должен быть вызван
   - **Фактический результат:** `updateProgress` вызывается 3 раза, прогресс не синхронизируется
   - **Статус:** ❌ Падает (проблема с изоляцией тестов)

3. **`testProgressSnapshotPhotosForUploadLogic`** - проверяет логику снимков
   - **Сценарий:** Создание снимка прогресса с смешанными операциями (удаление + добавление)
   - **Ожидание:** `shouldDeletePhoto = true`, `photosForUpload` содержит только не удаленные фото
   - **Фактический результат:** Логика снимков работает корректно
   - **Статус:** ✅ Проходит

**Анализ результатов тестов:**

**Проблема с изоляцией тестов:** Тесты используют общий `ModelContext`, и данные от предыдущих тестов влияют на следующие. Это приводит к неожиданным результатам:
- `updateProgressCallCount = 3` вместо ожидаемого `1` из-за влияния других тестов
- `isSynced = false` из-за конфликтов между тестами

**Подтверждение бага:** Первый тест падает, но не так, как ожидалось:
- `deletePhotoCallCount = 0` - `deletePhoto` не был вызван
- `updateProgressCallCount = 3` - `updateProgress` был вызван 3 раза
- `shouldDeletePhoto(.back) = true` - флаг удаления не был сброшен

**Корневая причина:** Баг еще серьезнее, чем изначально предполагалось. Даже корректный сценарий (замена в том же слоте) не работает из-за проблем с изоляцией тестов и фундаментальными проблемами в логике синхронизации.

### План исправления (ОБНОВЛЕНО)

#### Этап 1: Исправление логики обновления фотографий из серверного ответа

**Проблема:** `updateProgressFromServerResponse` перезаписывает локальные флаги удаления серверными данными.

**Решение:** Учитывать локальные флаги удаления при обновлении из серверного ответа.

```swift
// Исправленная логика
func updateProgressFromServerResponse(_ progress: Progress, _ response: ProgressResponse) async {
    logger.info("Обновляем фотографии для прогресса дня \(progress.id) из ответа сервера")

    // Обновляем URL фотографий только если они НЕ помечены для удаления локально
    if !progress.shouldDeletePhoto(.front) {
        progress.urlPhotoFront = response.photoFront
    }
    if !progress.shouldDeletePhoto(.back) {
        progress.urlPhotoBack = response.photoBack
    }
    if !progress.shouldDeletePhoto(.side) {
        progress.urlPhotoSide = response.photoSide
    }

    // Устанавливаем lastModified в соответствии с серверным временем
    progress.updateLastModified(from: response)

    // Загружаем фотографии только те, что НЕ помечены для удаления
    await downloadPhotosRespectingDeletionFlags(for: progress)

    progress.isSynced = true
    logger.info("Прогресс дня \(progress.id) обновлен из ответа сервера")
}
```

#### Этап 2: Создание метода загрузки фотографий с учетом флагов удаления

**Новый метод в ProgressSyncService:**

```swift
/// Загружает фотографии с сервера, учитывая локальные флаги удаления
private func downloadPhotosRespectingDeletionFlags(for progress: Progress) async {
    // Загружаем только те фотографии, что не помечены для удаления
    if !progress.shouldDeletePhoto(.front), let url = progress.urlPhotoFront {
        await PhotoDownloadService().downloadPhoto(for: progress, type: .front, url: url)
    }
    if !progress.shouldDeletePhoto(.back), let url = progress.urlPhotoBack {
        await PhotoDownloadService().downloadPhoto(for: progress, type: .back, url: url)
    }
    if !progress.shouldDeletePhoto(.side), let url = progress.urlPhotoSide {
        await PhotoDownloadService().downloadPhoto(for: progress, type: .side, url: url)
    }
}
```

#### Этап 3: Исправление проблемы с множественными записями

**Проблема:** 36 записей прогресса для одного дня указывает на серьезную проблему с дублированием.

**Анализ проблемы:**
- Все 36 записей имеют одинаковые данные (`isSynced=false, shouldDelete=false, isEmpty=false`)
- Все записи отправляются на сервер одновременно
- Это приводит к множественным запросам и ошибкам сервера
- Дублирование может быть вызвано проблемами в логике создания/обновления записей

**Решение:** 
1. Улучшить логику очистки дубликатов в `cleanupDuplicateProgress`
2. Добавить проверки на создание дубликатов при создании новых записей
3. Добавить логирование для отслеживания источников дублирования
4. Рассмотреть использование уникальных индексов в SwiftData модели

#### Этап 4: Обновление PhotoDownloadService

**Проблема:** `downloadAllPhotos` загружает все фотографии без учета локальных флагов удаления.

**Решение:** Создать метод `downloadPhoto` для загрузки отдельных фотографий или модифицировать `downloadAllPhotos` для учета флагов удаления.

#### Этап 5: Обновление тестов

**Добавить тесты для:**
1. Проверки, что удаленные фотографии не восстанавливаются при синхронизации
2. Проверки, что URL удаленных фотографий не обновляются из серверного ответа
3. Проверки, что PhotoDownloadService не загружает удаленные фотографии
4. Интеграционных тестов полного цикла удаления и синхронизации

### Ожидаемые результаты после исправления (ОБНОВЛЕНО)

**Метрики успеха:**
- ✅ Удаленные фотографии НЕ восстанавливаются при синхронизации
- ✅ URL удаленных фотографий НЕ обновляются из серверного ответа
- ✅ PhotoDownloadService НЕ загружает удаленные фотографии
- ✅ Множественные записи прогресса устраняются
- ✅ Все существующие тесты продолжают проходить
- ✅ Новые тесты для проверки корректности удаления проходят

**Тестовые сценарии:**
1. **Удаление фотографии** → фотография остается удаленной после синхронизации
2. **Удаление и добавление новой фотографии** → удаление сохраняется, новая загружается
3. **Множественные операции с фотографиями** → все операции выполняются корректно
4. **Синхронизация после удаления** → удаленные фотографии не восстанавливаются

### Риски исправления (ОБНОВЛЕНО)

1. **Побочные эффекты:** Изменение логики загрузки фотографий может повлиять на другие сценарии
2. **Совместимость:** Убедиться, что исправление не нарушает существующую функциональность загрузки фотографий
3. **Тестирование:** Требуется тщательное тестирование всех сценариев работы с фотографиями
4. **Множественные записи:** Проблема с дублированием записей может быть связана с другими багами
5. **PhotoDownloadService:** Модификация сервиса загрузки фотографий может повлиять на производительность

### Приоритет исправления

**КРИТИЧЕСКИЙ** - баг приводит к потере пользовательских данных (удаленные фотографии восстанавливаются), что является серьезной проблемой для пользовательского опыта.

### Порядок исправления (РЕКОМЕНДУЕМЫЙ)

**Этап 1 (КРИТИЧЕСКИЙ):** Исправление логики обновления фотографий
- Исправить `updateProgressFromServerResponse` для учета локальных флагов удаления
- Создать `downloadPhotosRespectingDeletionFlags` для корректной загрузки фотографий
- **Результат:** Удаленные фотографии перестанут восстанавливаться

**Этап 2 (ВЫСОКИЙ):** Исправление проблемы с множественными записями
- Улучшить логику очистки дубликатов
- Добавить проверки на создание дубликатов
- **Результат:** Устранение множественных запросов и ошибок сервера

**Этап 3 (СРЕДНИЙ):** Обновление PhotoDownloadService
- Создать метод для загрузки отдельных фотографий
- Модифицировать логику загрузки для учета флагов удаления
- **Результат:** Более эффективная загрузка фотографий

**Этап 4 (НИЗКИЙ):** Обновление тестов
- Добавить тесты для проверки корректности удаления
- Исправить изоляцию тестов
- **Результат:** Надежное тестирование функциональности
```
