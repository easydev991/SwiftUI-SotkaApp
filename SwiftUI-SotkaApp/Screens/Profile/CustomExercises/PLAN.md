## План доработок экрана пользовательских упражнений (Custom Exercises)

### Цели
- **Создать полноценный CRUD** для пользовательских упражнений на SwiftData.
- **Консистентный UX** в стиле SWDesignSystem, с локализацией и доступностью.
- **Надежная валидация** и устойчивость к ошибкам (OSLog + пользовательские алерты).
- **Покрыть бизнес-логику тестами** (Swift Testing).

### Текущее состояние
- **Экран списка**: `CustomExercisesScreen` — отображает список `CustomExercise` с пустым состоянием, поиском/фильтрацией по названию, сортировкой (по дате изменения/имени), кнопкой добавления.
- **Экран добавления**: `AddCustomExerciseScreen` — ввод названия, выбор иконки, проверка `canSaveExercise`, проверка дубликата в `Model.isDuplicate`, сохранение в SwiftData с алертом ошибок (`SWAlert`) и логированием (`OSLog`).
- **Экран редактирования**: `EditCustomExerciseScreen` — редактирование существующего упражнения с предзаполнением данных, сохранение изменений.
- **Удаление упражнений**: через `swipeActions` с подтверждением удаления.
- **Навигация**: переходы между экранами списка, добавления и редактирования.

### Бэклог задач (итерации)

#### Итерация 1 — UX и базовый CRUD
- [x] Добавить пустой стейт на `CustomExercisesScreen` с CTA «Create exercise» и навигацией на форму добавления.
- [x] Добавить поиск/фильтр по названию на `CustomExercisesScreen` (через локальное состояние + фильтрация `@Query` результата).
- [x] Сортировка списка (по дате изменения, по имени) с переключателем.
- [x] Редактирование упражнения: экран на базе `AddCustomExerciseScreen` с предзаполнением модели и сохранением изменений (без дублирования кода формы).
- [x] Удаление упражнения через `swipeActions` с подтверждением, переход к редактированию.

#### Итерация 2 — Модель, данные и офлайн-приоритет
- [x] Пересмотреть модель `CustomExercise` (обязательные поля, индексы/уникальность на уровне бизнес-логики). В SwiftData нет встроенных уникальных ограничений — оставить проверку дубликатов в коде сохранения.
- [x] Добавить поле `usageCount` (на перспективу сортировки по частоте использования).
- [x] Обеспечить мягкую миграцию данных при добавлении полей (описание шага миграции в README проекта).
- [x] **Обновить модель `CustomExercise`** с флагами синхронизации:
  - Добавить `isSynced: Bool = false` — флаг синхронизации с сервером
  - Добавить `shouldDelete: Bool = false` — флаг для удаления с сервера
  - Использовать существующее поле `modifyDate` как `lastModified` для отслеживания изменений
- [x] **Приоритет офлайн-работы**:
  - Все операции (создание, редактирование, удаление) **сначала** сохраняются локально в SwiftData
  - Синхронизация с сервером происходит **асинхронно** и **неблокирующе**
  - Приложение работает **полностью офлайн** без интернета
  - Показывать статус синхронизации отдельно от основного UI
- [x] **Расширить `ExerciseClient` протокол** (в `Services/Protocols/ExerciseClient.swift`):
  - `getCustomExercises() async throws -> [CustomExerciseResponse]` — получение списка упражнений
  - `saveCustomExercise(id: String, exercise: CustomExerciseRequest) async throws -> CustomExerciseResponse` — создание/обновление (универсальный метод)
  - `deleteCustomExercise(id: String) async throws` — удаление упражнения
- [x] **Добавить новые endpoints в `SWClient`** (на основе SOTKA-OBJc):
  - `GET v3/100/custom_exercises` — получение списка упражнений
  - `POST v3/100/custom_exercises/<id>` — создание/обновление упражнения (универсальный endpoint)
  - `DELETE v3/100/custom_exercises/<id>` — удаление упражнения
- [x] **Создать модель запроса** `CustomExerciseRequest` (в `Models/Workout/` на основе SOTKA-OBJc):
  - `id: String` — идентификатор упражнения
  - `name: String` — название упражнения
  - `image_id: Int` — ID иконки
  - `create_date: String` — дата создания (ISO формат)
  - `modify_date: String?` — дата изменения (ISO формат, опционально)
  - `is_hidden: Bool` — скрыто ли упражнение
- [x] **Доработать `CustomExercisesService`** с офлайн-приоритетом (на основе SOTKA-OBJc):
  - **Локальное сохранение** — всегда и немедленно
  - **Синхронизация** — только при наличии интернета и авторизации
  - `createCustomExercise()` — создание с локальным сохранением
  - `updateCustomExercise()` — обновление с локальным сохранением
  - `deleteCustomExercise()` — удаление с локальным сохранением
  - `syncUnsyncedExercises()` — синхронизация всех несинхронизированных данных
  - `syncSingleExercise()` — синхронизация одного упражнения
  - **Обработка ошибок**: при ошибке синхронизации — продолжать работу локально
  - Обработка ошибок сети с логированием через `OSLog`
- [x] **Интеграция в экраны** с офлайн-приоритетом:
  - При сохранении в `AddCustomExerciseScreen` — **сначала** сохранять локально, **потом** синхронизировать
  - При редактировании — **сначала** обновлять локально, **потом** синхронизировать
  - При удалении — **сначала** помечать для удаления локально, **потом** удалять с сервера
  - Показывать индикатор синхронизации отдельно от основного UI
  - **Никогда не блокировать** UI ожиданием синхронизации
- [x] **Обработка конфликтов** (адаптировано под существующий паттерн StatusManager):
  - **Двунаправленная синхронизация**: Сначала отправляем локальные изменения на сервер, потом загружаем серверные
  - **Стратегия "Last Write Wins"**: При конфликте используется версия с более поздним `modifyDate`
  - **Логирование конфликтов**: Все конфликты логируются через `OSLog` с деталями (ID, даты, источник)
  - **Автоматическое разрешение**: Конфликты разрешаются автоматически без участия пользователя
  - **Fallback стратегия**: При ошибке синхронизации — продолжать работу локально, повторять попытки синхронизации
  - **Доработка syncCustomExercises**: Добавить отправку локальных изменений перед загрузкой серверных

#### Итерация 3 — UI/Design
- [ ] Улучшить грид выбора иконок: явное состояние выбора, ховер/фокус состояния, доступность (VoiceOver labels).
- [ ] Добавить `Accessibility` (labels/hints/traits) для кнопок и элементов списка.

#### Итерация 4 — Тесты и качество
- [ ] Unit-тесты (Swift Testing) для `AddCustomExerciseScreen.Model`: `isDuplicate`, `canSaveExercise`, генерация `newExercise`.
- [ ] Unit-тесты для логики редактирования/удаления (через инъекцию тестового `ModelContext` или мок-слоя репозитория при необходимости).
- [ ] **Unit-тесты для серверной интеграции**:
  - Тесты `CustomExercisesService` с моками API клиента
  - Тесты обработки ошибок сети (таймауты, 404, 500)
  - Тесты синхронизации с конфликтами данных
- [ ] Проверка локализации: наличие ключей, базовые снапшоты строк (минимально — smoke через доступ к Localizable).
- [ ] Логирование ошибок сохранения/удаления через `OSLog` — проверить что сообщения информативны и не содержат приватные данные.

#### Итерация 5 — Производительность и стабильность
- [ ] Оптимизировать отрисовку `LazyVGrid` и списка: избегать лишних перерисовок при выборе иконок (минимизация стейта, `animation` только на нужных элементах).
- [ ] Защититься от редких гонок при быстром многократном нажатии «Save» (добавить флаг `isSaving`, дизейблить кнопку, повторная проверка дубликата перед сохранением).

### Критерии приемки
- Пользователь может: создать, отредактировать и удалить упражнение, быстро найти его через поиск, менять сортировку.
- Валидация: нельзя сохранить пустое имя, нельзя сохранить дубликат (имя + иконка).
- **Офлайн-приоритет**: приложение работает полностью без интернета, все данные сохраняются локально в SwiftData.
- **Серверная синхронизация**: происходит асинхронно и неблокирующе, при ошибке синхронизации работа продолжается локально.
- **Флаги синхронизации**: все модели имеют `isSynced`, `shouldDelete`, `lastModified` для отслеживания статуса.
- **UI не блокируется**: синхронизация не блокирует пользовательский интерфейс, статус показывается отдельно.
- Все пользовательские строки локализованы.
- Ошибки сохранения/удаления отображаются через `SWAlert` и логируются через `OSLog`.
- Написаны и проходят unit-тесты для бизнес-логики модели, CRUD-операций и серверной интеграции.
- **Тестирование офлайн**: все функции протестированы без интернета.

### Технические заметки
- DI и состояние: локальная логика формы — через `@State`/внутреннюю `Model`; доступ к SwiftData — через `@Environment(\.modelContext)`.
- Не вводить глобальные сервисы для локальной логики экрана; общие зависимости — через `Environment`.
- **Серверная интеграция**: следовать архитектуре проекта:
  - Расширить `ExerciseClient` протокол в `Services/Protocols/`
  - Добавить endpoints в `SWClient` через extension
  - Создать `CustomExerciseRequest` модель в `Models/Workout/`
  - Использовать `CustomExercisesService` для бизнес-логики
  - Все серверные операции через протоколы клиентов, не прямые вызовы
- Соблюдать стиль именования: функции построения View — `make...`, вычислимые свойства — без префикса `make`.
- Логи через `OSLog`, без TODO-комментариев.
- **API endpoints** (на основе StreetWorkoutSU): `v3/100/custom_exercises` с методами GET, POST, DELETE.

### Команды
- Сборка (симулятор iPhone 16 Pro): `make build`
- Тесты: `make test`
- Форматирование: `make format`

### Референсы
- Паттерны экранов со списками: `SwiftUI-Days` (`MainScreen`, навигация, `List`, `swipeActions`).
- Архитектурные и код-правила: `.cursor/rules/sotka-development.mdc`.
- **Офлайн-приоритет**: `.cursor/rules/offline-priority.mdc` — правила офлайн-работы и синхронизации.

## Стратегии обработки конфликтов синхронизации

### Анализ существующего функционала в новом приложении

**Найденные паттерны в StatusManager (аналогично SOTKA-OBJc):**
1. **Пользовательский выбор при конфликтах**: При конфликте дат старта показывается `SyncStartDateView` с выбором между данными приложения и сервера
2. **Модель конфликта**: `ConflictingStartDate` с двумя `DayCalculator` (app/site)
3. **UI паттерн**: Sheet с двумя опциями выбора, анимации, кнопка "Done"
4. **Автоматическое обновление**: После выбора вызывается соответствующий метод синхронизации

**Текущее состояние CustomExercisesService:**
1. **Односторонняя синхронизация**: Только загрузка с сервера, локальные изменения не отправляются
2. **Серверный приоритет**: Локальные данные обновляются только если серверная версия новее
3. **Проблема**: Локальные изменения могут быть потеряны при конфликтах

### Предлагаемые стратегии для нового приложения

#### 1. Двунаправленная синхронизация (Рекомендуемая)
```swift
// Обновленный syncCustomExercises
func syncCustomExercises(context: ModelContext) async {
    // 1. Сначала отправляем локальные изменения на сервер
    await syncUnsyncedExercises(context: context)
    
    // 2. Потом загружаем серверные изменения
    await downloadServerExercises(context: context)
}
```

#### 2. Стратегия "Last Write Wins" для конфликтов
```swift
// При конфликте в downloadServerExercises
if serverModifyDate > localModifyDate {
    // Серверная версия новее - обновляем локальную
    updateLocalFromServer(local, server)
} else {
    // Локальная версия новее - уже отправлена на сервер
    logger.info("Локальная версия новее серверной, пропускаем обновление")
}
```

#### 3. Детальное логирование конфликтов
```swift
private func logConflict(exerciseId: String, localDate: Date, serverDate: Date, resolution: String) {
    logger.info("Конфликт разрешен для упражнения \(exerciseId): локальная \(localDate) vs серверная \(serverDate) -> \(resolution)")
}
```

#### 4. Автоматическое разрешение без UI
- **Принцип**: Пользователь не участвует в разрешении конфликтов (в отличие от StatusManager)
- **Логика**: Всегда выбирается более новая версия по `modifyDate`
- **Логирование**: Все конфликты детально логируются для отладки

#### 5. Fallback стратегия при ошибках
- **Повторные попытки**: При ошибке синхронизации повторять через экспоненциальные интервалы
- **Локальная работа**: Приложение продолжает работать локально даже при ошибках синхронизации
- **Фоновые попытки**: Синхронизация происходит в фоне при следующем запуске приложения

#### 6. Специальные случаи
- **Удаленные элементы**: Если элемент удален на сервере, но изменен локально - локальная версия восстанавливается
- **Созданные локально**: Новые элементы всегда создаются на сервере с локальным ID
- **Конфликты имен**: При одинаковых именах упражнений - используется ID для различения

### Реализация в CustomExercisesService

#### Обновленный syncCustomExercises
```swift
func syncCustomExercises(context: ModelContext) async {
    guard !isLoading else { return }
    isLoading = true

    // 1. Сначала отправляем локальные изменения на сервер
    await syncUnsyncedExercises(context: context)
    
    // 2. Потом загружаем серверные изменения
    await downloadServerExercises(context: context)
    
    isLoading = false
}

private func downloadServerExercises(context: ModelContext) async {
    // Получаем пользователя
    guard let user = try? context.fetch(FetchDescriptor<User>()).first else { return }
    
    do {
        let exercises = try await client.getCustomExercises()
        let existingExercises = try context.fetch(FetchDescriptor<CustomExercise>())
            .filter { $0.user?.id == user.id }
        let existingDict = Dictionary(uniqueKeysWithValues: existingExercises.map { ($0.id, $0) })

        for exerciseResponse in exercises {
            if let existingExercise = existingDict[exerciseResponse.id] {
                let serverModifyDate = DateFormatterService.dateFromString(
                    exerciseResponse.modifyDate, format: .serverDateTimeSec
                )
                
                if serverModifyDate > existingExercise.modifyDate {
                    // Серверная версия новее - обновляем локальную
                    updateLocalFromServer(existingExercise, exerciseResponse)
                    logConflict(
                        exerciseId: existingExercise.id,
                        localDate: existingExercise.modifyDate,
                        serverDate: serverModifyDate,
                        resolution: "Серверная версия новее"
                    )
                } else {
                    // Локальная версия новее - уже отправлена на сервер
                    logger.info("Локальная версия новее серверной для \(existingExercise.name)")
                }
            } else {
                // Создаем новое упражнение с сервера
                let newExercise = CustomExercise(from: exerciseResponse, user: user)
                context.insert(newExercise)
            }
        }
        
        try context.save()
        logger.info("Серверные упражнения загружены")
    } catch {
        logger.error("Ошибка загрузки серверных упражнений: \(error.localizedDescription)")
    }
}
```

### Преимущества предлагаемого подхода

1. **Консистентность**: Использует тот же паттерн, что и StatusManager, но без UI
2. **Двунаправленная синхронизация**: Локальные изменения не теряются
3. **Автоматическое разрешение**: Пользователь не участвует в разрешении конфликтов
4. **Надежность**: Всегда есть "истина" - более новая версия по `modifyDate`
5. **Производительность**: Нет блокировки UI ожиданием пользовательского выбора
6. **Логирование**: Полная трассировка всех конфликтов для отладки
7. **Офлайн-приоритет**: Приложение работает локально, синхронизация в фоне

### Ключевые отличия от StatusManager

| Аспект | StatusManager | CustomExercisesService |
|--------|---------------|------------------------|
| **UI для конфликтов** | ✅ Sheet с выбором | ❌ Автоматическое разрешение |
| **Тип данных** | Одна дата старта | Множество упражнений |
| **Частота конфликтов** | Редко (при первом запуске) | Часто (при каждом редактировании) |
| **Пользовательский опыт** | Выбор между вариантами | Прозрачная синхронизация |
| **Сложность реализации** | Высокая (UI + логика) | Средняя (только логика) |


