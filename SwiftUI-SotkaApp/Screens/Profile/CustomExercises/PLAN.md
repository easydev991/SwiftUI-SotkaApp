## План доработок экрана пользовательских упражнений (Custom Exercises)

### Цели
- **Создать полноценный CRUD** для пользовательских упражнений на SwiftData.
- **Консистентный UX** в стиле SWDesignSystem, с локализацией и доступностью.
- **Надежная валидация** и устойчивость к ошибкам (OSLog + пользовательские алерты).
- **Покрыть бизнес-логику тестами** (Swift Testing).

### Текущее состояние
- **Экран списка**: `CustomExercisesScreen` — отображает список `CustomExercise` с пустым состоянием, поиском/фильтрацией по названию, сортировкой (по дате изменения/имени), кнопкой добавления.
- **Экран добавления**: `AddCustomExerciseScreen` — ввод названия, выбор иконки, проверка `canSaveExercise`, проверка дубликата в `Model.isDuplicate`, сохранение в SwiftData с алертом ошибок (`SWAlert`) и логированием (`OSLog`).
- **Экран редактирования**: `EditCustomExerciseScreen` — редактирование существующего упражнения с предзаполнением данных, сохранение изменений.
- **Удаление упражнений**: через `swipeActions` с подтверждением удаления.
- **Навигация**: переходы между экранами списка, добавления и редактирования.

### Бэклог задач (итерации)

#### Итерация 1 — UX и базовый CRUD
- [x] Добавить пустой стейт на `CustomExercisesScreen` с CTA «Create exercise» и навигацией на форму добавления.
- [x] Добавить поиск/фильтр по названию на `CustomExercisesScreen` (через локальное состояние + фильтрация `@Query` результата).
- [x] Сортировка списка (по дате изменения, по имени) с переключателем.
- [x] Редактирование упражнения: экран на базе `AddCustomExerciseScreen` с предзаполнением модели и сохранением изменений (без дублирования кода формы).
- [x] Удаление упражнения через `swipeActions` с подтверждением, переход к редактированию.

#### Итерация 2 — Модель и данные
- [x] Пересмотреть модель `CustomExercise` (обязательные поля, индексы/уникальность на уровне бизнес-логики). В SwiftData нет встроенных уникальных ограничений — оставить проверку дубликатов в коде сохранения.
- [ ] Добавить поле `usageCount` (на перспективу сортировки по частоте использования).
- [ ] Обеспечить мягкую миграцию данных при добавлении полей (описание шага миграции в README проекта).
- [ ] **Интегрировать с "Итерацией 2.5"**: добавить флаги синхронизации (`isSynced`, `shouldDelete`) и использовать существующее поле `modifyDate` как `lastModified`.

#### Итерация 2.5 — Офлайн-приоритет и серверная синхронизация
- [ ] **Обновить модель `CustomExercise`** с флагами синхронизации:
  - Добавить `isSynced: Bool = false` — флаг синхронизации с сервером
  - Добавить `shouldDelete: Bool = false` — флаг для удаления с сервера
  - Использовать существующее поле `modifyDate` как `lastModified` для отслеживания изменений
- [ ] **Приоритет офлайн-работы**:
  - Все операции (создание, редактирование, удаление) **сначала** сохраняются локально в SwiftData
  - Синхронизация с сервером происходит **асинхронно** и **неблокирующе**
  - Приложение работает **полностью офлайн** без интернета
  - Показывать статус синхронизации отдельно от основного UI
- [ ] **Расширить `ExerciseClient` протокол** (в `Services/Protocols/ExerciseClient.swift`):
  - `getCustomExercises() async throws -> [CustomExerciseResponse]` — получение списка упражнений
  - `saveCustomExercise(id: String, exercise: CustomExerciseRequest) async throws -> CustomExerciseResponse` — создание/обновление (универсальный метод)
  - `deleteCustomExercise(id: String) async throws` — удаление упражнения
- [ ] **Добавить новые endpoints в `SWClient`** (на основе SOTKA-OBJc):
  - `GET v3/100/custom_exercises` — получение списка упражнений
  - `POST v3/100/custom_exercises/<id>` — создание/обновление упражнения (универсальный endpoint)
  - `DELETE v3/100/custom_exercises/<id>` — удаление упражнения
- [ ] **Создать модель запроса** `CustomExerciseRequest` (в `Models/Workout/` на основе SOTKA-OBJc):
  - `id: String` — идентификатор упражнения
  - `name: String` — название упражнения
  - `image_id: Int` — ID иконки
  - `create_date: String` — дата создания (ISO формат)
  - `modify_date: String?` — дата изменения (ISO формат, опционально)
  - `is_hidden: Bool` — скрыто ли упражнение
- [ ] **Доработать `CustomExercisesService`** с офлайн-приоритетом (на основе SOTKA-OBJc):
  - **Локальное сохранение** — всегда и немедленно
  - **Синхронизация** — только при наличии интернета и авторизации
  - `saveLocally(exercise: CustomExercise, context: ModelContext)` — локальное сохранение
  - `syncUnsyncedData(context: ModelContext, client: ExerciseClient) async` — рекурсивная синхронизация по одному элементу
  - `getCustomExercises(context: ModelContext, client: ExerciseClient) async throws` — получение с сервера
  - `saveCustomExercise(exercise: CustomExercise, context: ModelContext, client: ExerciseClient) async throws` — универсальное сохранение
  - `deleteCustomExercise(id: String, context: ModelContext, client: ExerciseClient) async throws` — удаление
  - **Обработка ошибок**: при ошибке 404/500 при удалении — удаление локально
  - Обработка ошибок сети с логированием через `OSLog`
- [ ] **Интеграция в экраны** с офлайн-приоритетом:
  - При сохранении в `AddCustomExerciseScreen` — **сначала** сохранять локально, **потом** синхронизировать
  - При редактировании — **сначала** обновлять локально, **потом** синхронизировать
  - При удалении — **сначала** помечать для удаления локально, **потом** удалять с сервера
  - Показывать индикатор синхронизации отдельно от основного UI
  - **Никогда не блокировать** UI ожиданием синхронизации
- [ ] **Обработка конфликтов**:
  - При синхронизации учитывать `lastModified` для определения последней версии
  - Локальные изменения имеют приоритет при конфликтах
  - Логирование конфликтов через `OSLog`
  - При ошибке синхронизации — продолжать работу локально

#### Итерация 3 — UI/Design
- [ ] Улучшить грид выбора иконок: явное состояние выбора, ховер/фокус состояния, доступность (VoiceOver labels).
- [ ] Категоризация/поиск иконок (если иконок станет много), возможность быстрого выбора последних использованных.
- [ ] Локализовать строки: «Custom exercises», «New exercise», «Save», «Enter exercise name», «Choose icon», тексты ошибок.
- [ ] Добавить `Accessibility` (labels/hints/traits) для кнопок и элементов списка.

#### Итерация 4 — Тесты и качество
- [ ] Unit-тесты (Swift Testing) для `AddCustomExerciseScreen.Model`: `isDuplicate`, `canSaveExercise`, генерация `newExercise`.
- [ ] Unit-тесты для логики редактирования/удаления (через инъекцию тестового `ModelContext` или мок-слоя репозитория при необходимости).
- [ ] **Unit-тесты для серверной интеграции**:
  - Тесты `CustomExercisesService` с моками API клиента
  - Тесты обработки ошибок сети (таймауты, 404, 500)
  - Тесты синхронизации с конфликтами данных
- [ ] Проверка локализации: наличие ключей, базовые снапшоты строк (минимально — smoke через доступ к Localizable).
- [ ] Логирование ошибок сохранения/удаления через `OSLog` — проверить что сообщения информативны и не содержат приватные данные.

#### Итерация 5 — Производительность и стабильность
- [ ] Оптимизировать отрисовку `LazyVGrid` и списка: избегать лишних перерисовок при выборе иконок (минимизация стейта, `animation` только на нужных элементах).
- [ ] Защититься от редких гонок при быстром многократном нажатии «Save» (добавить флаг `isSaving`, дизейблить кнопку, повторная проверка дубликата перед сохранением).

### Критерии приемки
- Пользователь может: создать, отредактировать и удалить упражнение, быстро найти его через поиск, менять сортировку.
- Валидация: нельзя сохранить пустое имя, нельзя сохранить дубликат (имя + иконка).
- **Офлайн-приоритет**: приложение работает полностью без интернета, все данные сохраняются локально в SwiftData.
- **Серверная синхронизация**: происходит асинхронно и неблокирующе, при ошибке синхронизации работа продолжается локально.
- **Флаги синхронизации**: все модели имеют `isSynced`, `shouldDelete`, `lastModified` для отслеживания статуса.
- **UI не блокируется**: синхронизация не блокирует пользовательский интерфейс, статус показывается отдельно.
- Все пользовательские строки локализованы.
- Ошибки сохранения/удаления отображаются через `SWAlert` и логируются через `OSLog`.
- Написаны и проходят unit-тесты для бизнес-логики модели, CRUD-операций и серверной интеграции.
- **Тестирование офлайн**: все функции протестированы без интернета.

### Технические заметки
- DI и состояние: локальная логика формы — через `@State`/внутреннюю `Model`; доступ к SwiftData — через `@Environment(\.modelContext)`.
- Не вводить глобальные сервисы для локальной логики экрана; общие зависимости — через `Environment`.
- **Серверная интеграция**: следовать архитектуре проекта:
  - Расширить `ExerciseClient` протокол в `Services/Protocols/`
  - Добавить endpoints в `SWClient` через extension
  - Создать `CustomExerciseRequest` модель в `Models/Workout/`
  - Использовать `CustomExercisesService` для бизнес-логики
  - Все серверные операции через протоколы клиентов, не прямые вызовы
- Соблюдать стиль именования: функции построения View — `make...`, вычислимые свойства — без префикса `make`.
- Логи через `OSLog`, без TODO-комментариев.
- **API endpoints** (на основе StreetWorkoutSU): `v3/100/custom_exercises` с методами GET, POST, DELETE.

### Команды
- Сборка (симулятор iPhone 16 Pro): `make build`
- Тесты: `make test`
- Форматирование: `make format`

### Референсы
- Паттерны экранов со списками: `SwiftUI-Days` (`MainScreen`, навигация, `List`, `swipeActions`).
- Архитектурные и код-правила: `.cursor/rules/sotka-development.mdc`.
- **Офлайн-приоритет**: `.cursor/rules/offline-priority.mdc` — правила офлайн-работы и синхронизации.


