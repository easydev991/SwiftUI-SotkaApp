### Документация: экран пользовательских упражнений (Custom Exercises)

Этот документ описывает реализованный функционал экрана пользовательских упражнений, устройство локального хранения, офлайн-приоритет и логику сервиса `CustomExercisesService.swift`. Док предназначен для нейросетей и разработчиков проекта.

### Краткий обзор функционала

- **Список упражнений**: отображение пользовательских упражнений текущего пользователя, скрытие элементов, помеченных к удалению.
- **Пустое состояние**: CTA для создания первого упражнения.
- **Поиск и фильтр**: фильтрация по названию (локально, без сети).
- **Сортировка**: по дате изменения и по имени; предусмотрено поле `usageCount` на будущее.
- **Создание**: форма ввода названия и выбора иконки, локальное сохранение, последующая синхронизация в фоне.
- **Редактирование**: предзаполнение полей, локальное сохранение изменений, последующая синхронизация.
- **Удаление**: мягкое удаление (soft delete) — элемент помечается флагом, сразу скрывается из UI, серверное удаление асинхронно.
- **Навигация**: переходы список → добавление → редактирование.
- **Доступность и логирование**: логи на русском, UI не блокируется синхронизацией.

### Модель данных: `CustomExercise`

- `id: String` — идентификатор (локально создается как timestamp + случайное число, затем согласуется с сервером по тому же значению).
- `name: String` — название упражнения; локальная защита от дубликатов по имени для текущего пользователя.
- `imageId: Int` — идентификатор иконки.
- `createDate: Date` — дата создания.
- `modifyDate: Date` — дата последнего изменения (используется как источник истины при разрешении конфликтов; аналог lastModified).
- `isSynced: Bool` — синхронизировано ли состояние с сервером.
- `shouldDelete: Bool` — пометка на удаление (элемент скрывается из UI, удаляется на сервере при следующей синхронизации, затем удаляется локально физически).
- Дополнительно: потенциальное поле `usageCount` для будущих сценариев сортировки по частоте.

### Офлайн-приоритет

- Все операции (создание, обновление, удаление) сначала сохраняются локально в SwiftData.
- Синхронизация с сервером выполняется асинхронно, неблокирующе для обычных пользовательских действий.
- При сетевых ошибках работа продолжается локально; состояние помечается как несинхронизированное.
- Конфликты разрешаются автоматически по стратегии LWW (Last Write Wins) на основе поля `modifyDate`.

### Сетевая интеграция (через `ExerciseClient`/`SWClient`)

- `GET v3/100/custom_exercises` — получение списка пользовательских упражнений.
- `POST v3/100/custom_exercises/<id>` — создание/обновление упражнения.
- `DELETE v3/100/custom_exercises/<id>` — удаление упражнения.

Интерфейс клиента (сокращенно):
- `getCustomExercises() async throws -> [CustomExerciseResponse]`
- `saveCustomExercise(id: String, exercise: CustomExerciseRequest) async throws -> CustomExerciseResponse`
- `deleteCustomExercise(id: String) async throws`

Модели запросов/ответов содержат ISO-строки дат (`create_date`, `modify_date`) и поля `name`, `image_id`, `is_hidden`.

### Сервис: `CustomExercisesService`

Сервис помечен `@MainActor` и `@Observable`. Все логи — на русском языке (`OSLog`).

- **Публичные свойства**:
  - `isLoading: Bool` — индикатор общей синхронизации (двунаправленной).
  - `isSyncing: Bool` — индикатор отправки несинхронизированных изменений.

- **Создание**: `createCustomExercise(name:imageId:context:)`
  - Защищает от локального конфликта имен для текущего пользователя (добавляет суффикс со временем, если имя занято и элемент не помечен к удалению).
  - Создает локальный `id` на основе `timestamp` + случайного числа.
  - Вставляет в SwiftData и сохраняет; ставит `isSynced = false` (по умолчанию) и актуальную `modifyDate`.
  - Логи: успешное локальное создание и указание, что синхронизация выполняется отдельно.

- **Обновление**: `markCustomExerciseAsModified(_:context:)`
  - Проставляет `modifyDate = now` и `isSynced = false`, затем сохраняет контекст.
  - Синхронизация изменений выполняется отдельно через `syncCustomExercises(context:)`.

- **Пометка как измененного**: `markCustomExerciseAsModified(_:context:)`
  - Обновляет `modifyDate` и `isSynced = false`; сохраняет контекст.

- **Удаление (soft)**: `deleteCustomExercise(_:context:)`
  - Не удаляет объект физически сразу.
  - Ставит `shouldDelete = true`, `isSynced = false`, обновляет `modifyDate` и сохраняет контекст.
  - UI фильтрует такие элементы и не показывает их пользователю.

- **Синхронизация несинхронизированных**: `syncUnsyncedExercises(context:)`
  - Реализована схема snapshot → group → apply.
  - На этапе snapshot: из `ModelContext` собираются только необходимые неизменяемые данные (`ExerciseSnapshot`).
  - На этапе group: параллельно (через `withTaskGroup`) выполняются чистые сетевые операции без доступа к `ModelContext`, для каждого снимка формируется `SyncEvent`:
    - `.createdOrUpdated(id:server)` — сервер вернул актуальную сущность.
    - `.deleted(id)` — сервер подтвердил удаление.
    - `.failed(id:errorDescription)` — ошибка сети/сервера.
  - На этапе apply: все события применяются к `ModelContext` одним проходом на главной очереди:
    - Для `createdOrUpdated` — обновление локальной сущности данными ответа сервера, `isSynced = true`, `shouldDelete = false`, даты приводятся из серверных строк.
    - Для `deleted` — физическое удаление локального объекта.
    - Для `failed` — только логирование, локальное состояние сохраняется для последующих повторов.

- **Двунаправленная синхронизация**: `syncCustomExercises(context:)`
  - Сначала вызывает `syncUnsyncedExercises` (локальные → сервер).
  - Затем `downloadServerExercises` (сервер → локальные) с автоматическим разрешением конфликтов по LWW.

- **Загрузка с сервера и LWW**: `downloadServerExercises(context:)`
  - Загружает все упражнения пользователя и сопоставляет с локальными по `id`.
  - Если локальная сущность помечена `shouldDelete`, она пропускается (не восстанавливается серверными данными).
  - Если `local.modifyDate > server.modify_date` — сохраняется локальная версия (мы уже отправили изменения).
  - Если `server.modify_date > local.modifyDate` — локальная сущность обновляется по данным сервера и помечается синхронизированной.
  - Для синхронизированных элементов, отсутствующих на сервере, — ставится `shouldDelete = true` и `isSynced = false` (или выполняется физическое удаление, если удаление уже подтверждалось событием).

- **Повторные попытки**: в сервисе предусмотрен частный механизм повторов для поштучной синхронизации (метод `syncSingleExerciseWithRetry`), но основным путем является групповая синхронизация `syncUnsyncedExercises`.

- **Логирование (все сообщения на русском)**:
  - Старт/завершение синхронизаций, количество элементов к синку.
  - Подробности запросов при отправке (id, name, image_id, даты).
  - Результаты применения: «обновлено локально», «удалено локально», «пропущено (локальная версия новее)». 
  - Ошибки сети/применения с `error.localizedDescription` и деталями `APIError`, если доступен.

### UI: взаимодействие и поведение

- Обычные операции создания/редактирования/удаления не блокируют UI; синхронизация происходит в фоне.
- Элементы с `shouldDelete == true` скрываются из списка.
- Поиск, сортировка и пустое состояние реализованы локально и не зависят от сети.

### Тестирование и качество

- Юнит-тесты модели формы (проверка дубликатов, валидация, генерация новой модели) — планируются/поддерживаются средствами Swift Testing.
- Юнит-тесты сервиса с моками клиента: 
  - успех/ошибка сохранения, удаления, конфликтов; 
  - корректность применения событий `SyncEvent` и стратегии LWW.
- Проверки локализации пользовательских строк и корректности логов (на русском).

### Принципы расширения

- Новые поля в `CustomExercise` добавлять с учетом мягких миграций SwiftData.
- Для новых операций соблюдать офлайн-приоритет: локальные изменения в первую очередь, синхронизация — отдельно и неблокирующе.
- Все сетевые операции — через абстракции клиентов (`ExerciseClient`), без прямых вызовов внутри View.

### Ключевые правила

- Не блокировать UI ожиданием сети в экране упражнений.
- Всегда писать логи на русском с достаточным контекстом.
- Разрешать конфликты автоматически по `modifyDate`.
- Soft delete: сначала пометка и скрытие в UI, потом удаление на сервере и физическое удаление локально.
